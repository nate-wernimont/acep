Start -> $r0 = new java.util.Hashtable -> specialinvoke $r0.<java.util.Hashtable: void <init>()>() -> <jgfutil.JGFInstrumentor: java.util.Hashtable timers> = $r0 -> $r1 = new java.util.Hashtable -> specialinvoke $r1.<java.util.Hashtable: void <init>()>() -> <jgfutil.JGFInstrumentor: java.util.Hashtable data> = $r1 -> return -> i0 := @parameter0: int -> i1 := @parameter1: int -> i2 := @parameter2: int -> r0 = "" -> r1 = "Java Grande Forum Thread Benchmark Suite - Version 1.0 - Section " -> $r14 = new java.lang.StringBuilder -> $r15 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>(r1) -> specialinvoke $r14.<java.lang.StringBuilder: void <init>(java.lang.String)>($r15) -> $r16 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("3 - Size A") -> r0 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.String toString()>() -> goto [?= $r20 = <java.lang.System: java.io.PrintStream out>] -> $r20 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r20.<java.io.PrintStream: void println(java.lang.String)>(r0) -> if i2 != 1 goto $r26 = <java.lang.System: java.io.PrintStream out> -> $r21 = <java.lang.System: java.io.PrintStream out> -> $r22 = new java.lang.StringBuilder -> specialinvoke $r22.<java.lang.StringBuilder: void <init>(java.lang.String)>("Executing on ") -> $r23 = virtualinvoke $r22.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i2) -> $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" thread") -> $r25 = virtualinvoke $r24.<java.lang.StringBuilder: java.lang.String toString()>() -> virtualinvoke $r21.<java.io.PrintStream: void println(java.lang.String)>($r25) -> goto [?= $r31 = <java.lang.System: java.io.PrintStream out>] -> $r31 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r31.<java.io.PrintStream: void println(java.lang.String)>("") -> return ->  End~~~1
Start -> r0 := @this: montecarlo.CallAppDemo -> specialinvoke r0.<java.lang.Object: void <init>()>() -> $r1 = newarray (int)[2] -> $r1[0] = 10000 -> $r1[1] = 60000 -> r0.<montecarlo.CallAppDemo: int[] datasizes> = $r1 -> $r2 = newarray (int)[2] -> r0.<montecarlo.CallAppDemo: int[] input> = $r2 -> r0.<montecarlo.CallAppDemo: montecarlo.AppDemo ap> = null -> return ->  End~~~1
Start -> r0 := @this: montecarlo.JGFMonteCarloBench -> i0 := @parameter0: int -> specialinvoke r0.<montecarlo.CallAppDemo: void <init>()>() -> <montecarlo.JGFMonteCarloBench: int nthreads> = i0 -> return ->  End~~~1
Start -> r0 := @this: jgfutil.JGFTimer -> r1 := @parameter0: java.lang.String -> r2 := @parameter1: java.lang.String -> i0 := @parameter2: int -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<jgfutil.JGFTimer: int size> = -1 -> r0.<jgfutil.JGFTimer: java.lang.String name> = r1 -> r0.<jgfutil.JGFTimer: java.lang.String opname> = r2 -> r0.<jgfutil.JGFTimer: int size> = i0 -> virtualinvoke r0.<jgfutil.JGFTimer: void reset()>() -> r0 := @this: jgfutil.JGFTimer -> r0.<jgfutil.JGFTimer: double time> = 0.0 -> r0.<jgfutil.JGFTimer: long calls> = 0L -> r0.<jgfutil.JGFTimer: double opcount> = 0.0 -> r0.<jgfutil.JGFTimer: boolean on> = 0 -> return -> return ->  End~~~2
Start -> r0 := @parameter0: java.lang.String -> r1 := @parameter1: java.lang.String -> i0 := @parameter2: int -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r2.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r8 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r8 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r9 = new jgfutil.JGFTimer -> specialinvoke $r9.<jgfutil.JGFTimer: void <init>(java.lang.String,java.lang.String,int)>(r0, r1, i0) -> virtualinvoke $r8.<java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>(r0, $r9) -> return ->  End~~~2
Start -> r0 := @this: jgfutil.JGFTimer -> $z0 = r0.<jgfutil.JGFTimer: boolean on> -> if $z0 == 0 goto r0.<jgfutil.JGFTimer: boolean on> = 1 -> r0.<jgfutil.JGFTimer: boolean on> = 1 -> $l0 = staticinvoke <java.lang.System: long currentTimeMillis()>() -> r0.<jgfutil.JGFTimer: long start_time> = $l0 -> return ->  End~~~2
Start -> r0 := @parameter0: java.lang.String -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void start()>() -> goto [?= return] -> return ->  End~~~2
Start -> <montecarlo.AppDemo: double JGFavgExpectedReturnRateMC> = 0.0 -> <montecarlo.AppDemo: boolean DEBUG> = 1 -> <montecarlo.AppDemo: java.lang.String prompt> = "AppDemo> " -> <montecarlo.AppDemo: montecarlo.ToInitAllTasks initAllTasks> = null -> return ->  End~~~1
Start -> r0 := @this: montecarlo.Universal -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<montecarlo.Universal: boolean DEBUG> = 1 -> <montecarlo.Universal: boolean UNIVERSAL_DEBUG> = 1 -> r0.<montecarlo.Universal: java.lang.String prompt> = "Universal> " -> return ->  End~~~40004
Start -> r0 := @this: montecarlo.Universal -> r1 := @parameter0: java.lang.String -> r0.<montecarlo.Universal: java.lang.String prompt> = r1 -> return ->  End~~~60007
Start -> r0 := @this: montecarlo.Universal -> z0 := @parameter0: boolean -> r0.<montecarlo.Universal: boolean DEBUG> = z0 -> return ->  End~~~60007
Start -> r0 := @this: montecarlo.AppDemo -> r1 := @parameter0: java.lang.String -> r2 := @parameter1: java.lang.String -> i0 := @parameter2: int -> i1 := @parameter3: int -> specialinvoke r0.<montecarlo.Universal: void <init>()>() -> r0.<montecarlo.AppDemo: int nTimeStepsMC> = 0 -> r0.<montecarlo.AppDemo: int nRunsMC> = 0 -> r0.<montecarlo.AppDemo: double dTime> = 0.0027397260273972603 -> r0.<montecarlo.AppDemo: boolean initialised> = 0 -> r0.<montecarlo.AppDemo: double pathStartValue> = 100.0 -> r0.<montecarlo.AppDemo: double avgExpectedReturnRateMC> = 0.0 -> r0.<montecarlo.AppDemo: double avgVolatilityMC> = 0.0 -> r0.<montecarlo.AppDemo: java.lang.String dataDirname> = r1 -> r0.<montecarlo.AppDemo: java.lang.String dataFilename> = r2 -> r0.<montecarlo.AppDemo: int nTimeStepsMC> = i0 -> r0.<montecarlo.AppDemo: int nRunsMC> = i1 -> $r3 = <montecarlo.AppDemo: java.lang.String prompt> -> virtualinvoke r0.<montecarlo.AppDemo: void set_prompt(java.lang.String)>($r3) -> $z0 = <montecarlo.AppDemo: boolean DEBUG> -> virtualinvoke r0.<montecarlo.AppDemo: void set_DEBUG(boolean)>($z0) -> return ->  End~~~1
Start -> <montecarlo.PathId: boolean DEBUG> = 1 -> <montecarlo.PathId: java.lang.String prompt> = "PathId> " -> return ->  End~~~1
Start -> <montecarlo.RatePath: java.lang.String prompt> = "RatePath> " -> <montecarlo.RatePath: int DATUMFIELD> = 4 -> return ->  End~~~1
Start -> r0 := @this: montecarlo.PathId -> specialinvoke r0.<montecarlo.Universal: void <init>()>() -> r0.<montecarlo.PathId: int startDate> = 0 -> r0.<montecarlo.PathId: int endDate> = 0 -> r0.<montecarlo.PathId: double dTime> = #NaN -> $r1 = <montecarlo.PathId: java.lang.String prompt> -> virtualinvoke r0.<montecarlo.PathId: void set_prompt(java.lang.String)>($r1) -> $z0 = <montecarlo.PathId: boolean DEBUG> -> virtualinvoke r0.<montecarlo.PathId: void set_DEBUG(boolean)>($z0) -> return ->  End~~~30003
Start -> r1 := @parameter1: java.lang.String -> r2 = "split" -> i0 = 0 -> z0 = 0 -> i1 = 0 -> goto [?= $i2 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i1)] -> $i2 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i1) -> i3 = $i2 -> if $i2 > -1 goto i0 = i0 + 1 -> i0 = i0 + 1 -> i1 = i3 + 1 -> $z1 = <montecarlo.Utilities: boolean DEBUG> -> if $z1 == 0 goto $i4 = i0 + 1 -> $i4 = i0 + 1 -> r3 = newarray (java.lang.String)[$i4] -> i5 = 0 -> i6 = 0 -> goto [?= $i7 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i6)] -> $i7 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i6) -> i8 = $i7 -> if $i7 > -1 goto $z2 = <montecarlo.Utilities: boolean DEBUG> -> $z2 = <montecarlo.Utilities: boolean DEBUG> -> if $z2 == 0 goto $r24 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int,int)>(i6, i8) -> $r24 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int,int)>(i6, i8) -> r3[i5] = $r24 -> i5 = i5 + 1 -> i6 = i8 + 1 -> $r25 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(i6) -> r3[i5] = $r25 -> return r3 ->  End~~~9
Start -> r0 := @parameter0: java.lang.String -> r1 := @parameter1: java.lang.String -> r2 = "split" -> i0 = 0 -> z0 = 0 -> i1 = 0 -> goto [?= $i2 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i1)] -> $i2 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i1) -> i3 = $i2 -> if $i2 > -1 goto i0 = i0 + 1 -> i0 = i0 + 1 -> i1 = i3 + 1 -> $z1 = <montecarlo.Utilities: boolean DEBUG> -> if $z1 == 0 goto $i4 = i0 + 1 -> $i4 = i0 + 1 -> r3 = newarray (java.lang.String)[$i4] -> i5 = 0 -> i6 = 0 -> goto [?= $i7 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i6)] -> $i7 = virtualinvoke r1.<java.lang.String: int indexOf(java.lang.String,int)>(r0, i6) -> i8 = $i7 -> if $i7 > -1 goto $z2 = <montecarlo.Utilities: boolean DEBUG> -> $z2 = <montecarlo.Utilities: boolean DEBUG> -> if $z2 == 0 goto $r24 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int,int)>(i6, i8) -> $r24 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int,int)>(i6, i8) -> r3[i5] = $r24 -> i5 = i5 + 1 -> i6 = i8 + 1 -> $r25 = virtualinvoke r1.<java.lang.String: java.lang.String substring(int)>(i6) -> r3[i5] = $r25 -> return r3 ->  End~~~23364
Start -> r0 := @this: montecarlo.PathId -> r1 := @parameter0: java.lang.String -> r0.<montecarlo.PathId: java.lang.String name> = r1 -> return ->  End~~~10002
Start -> r0 := @this: montecarlo.PathId -> i0 := @parameter0: int -> r0.<montecarlo.PathId: int startDate> = i0 -> return ->  End~~~10002
Start -> r0 := @this: montecarlo.PathId -> i0 := @parameter0: int -> r0.<montecarlo.PathId: int endDate> = i0 -> return ->  End~~~10002
Start -> r0 := @this: montecarlo.PathId -> d0 := @parameter0: double -> r0.<montecarlo.PathId: double dTime> = d0 -> return ->  End~~~20002
Start -> <montecarlo.Utilities: boolean DEBUG> = 0 -> <montecarlo.Utilities: java.lang.String className> = "Utilities" -> return -> r0 := @parameter0: java.lang.String -> r10 = staticinvoke <montecarlo.Utilities: java.lang.String[] splitString(java.lang.String,java.lang.String)>(",", r33) -> $r34 = new java.lang.StringBuilder -> specialinvoke $r34.<java.lang.StringBuilder: void <init>(java.lang.String)>("19") -> $r35 = r10[0] -> $r36 = virtualinvoke $r34.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r35) -> $r37 = virtualinvoke $r36.<java.lang.StringBuilder: java.lang.String toString()>() -> i1 = staticinvoke <java.lang.Integer: int parseInt(java.lang.String)>($r37) -> $i5 = <montecarlo.RatePath: int DATUMFIELD> -> $r38 = r10[$i5] -> $r39 = staticinvoke <java.lang.Double: java.lang.Double valueOf(java.lang.String)>($r38) -> d0 = virtualinvoke $r39.<java.lang.Double: double doubleValue()>() -> if i1 <= 19000101 goto $r40 = new java.lang.StringBuilder -> $d1 = staticinvoke <java.lang.Math: double abs(double)>(d0) -> $b6 = $d1 cmpg 4.9E-323 -> if $b6 >= 0 goto $r47 = r0.<montecarlo.RatePath: int[] pathDate> -> $r47 = r0.<montecarlo.RatePath: int[] pathDate> -> $r47[i4] = i1 -> $r48 = r0.<montecarlo.RatePath: double[] pathValue> -> $r48[i4] = d0 -> i4 = i4 + 1 -> $z2 = interfaceinvoke r31.<java.util.Enumeration: boolean hasMoreElements()>() -> if $z2 != 0 goto $r32 = interfaceinvoke r31.<java.util.Enumeration: java.lang.Object nextElement()>() -> $r32 = interfaceinvoke r31.<java.util.Enumeration: java.lang.Object nextElement()>() -> r33 = (java.lang.String) $r32 -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = i4 -> $r49 = virtualinvoke r4.<java.io.File: java.lang.String getName()>() -> virtualinvoke r0.<montecarlo.RatePath: void set_name(java.lang.String)>($r49) -> $r50 = r0.<montecarlo.RatePath: int[] pathDate> -> $i7 = $r50[0] -> virtualinvoke r0.<montecarlo.RatePath: void set_startDate(int)>($i7) -> $r51 = r0.<montecarlo.RatePath: int[] pathDate> -> $i8 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> $i9 = $i8 - 1 -> $i10 = $r51[$i9] -> virtualinvoke r0.<montecarlo.RatePath: void set_endDate(int)>($i10) -> virtualinvoke r0.<montecarlo.RatePath: void set_dTime(double)>(0.0027397260273972603) -> return -> return ->  End~~~2493
Start -> r0 := @this: montecarlo.PathId -> return ->  End~~~2
Start -> <montecarlo.ReturnPath: boolean DEBUG> = 1 -> <montecarlo.ReturnPath: java.lang.String prompt> = "ReturnPath> " -> <montecarlo.ReturnPath: int COMPOUNDED> = 1 -> <montecarlo.ReturnPath: int NONCOMPOUNDED> = 2 -> return ->  End~~~1
Start -> r0 := @this: montecarlo.ReturnPath -> r1 := @parameter0: double[] -> i0 := @parameter1: int -> i1 := @parameter2: int -> specialinvoke r0.<montecarlo.PathId: void <init>()>() -> r0.<montecarlo.ReturnPath: int nPathValue> = 0 -> r0.<montecarlo.ReturnPath: int returnDefinition> = 0 -> r0.<montecarlo.ReturnPath: double expectedReturnRate> = #NaN -> r0.<montecarlo.ReturnPath: double volatility> = #NaN -> r0.<montecarlo.ReturnPath: double volatility2> = #NaN -> r0.<montecarlo.ReturnPath: double mean> = #NaN -> r0.<montecarlo.ReturnPath: double variance> = #NaN -> $r2 = <montecarlo.ReturnPath: java.lang.String prompt> -> virtualinvoke r0.<montecarlo.ReturnPath: void set_prompt(java.lang.String)>($r2) -> $z0 = <montecarlo.ReturnPath: boolean DEBUG> -> virtualinvoke r0.<montecarlo.ReturnPath: void set_DEBUG(boolean)>($z0) -> r0.<montecarlo.ReturnPath: double[] pathValue> = r1 -> r0.<montecarlo.ReturnPath: int nPathValue> = i0 -> r0.<montecarlo.ReturnPath: int returnDefinition> = i1 -> return ->  End~~~10001
Start -> r0 := @this: montecarlo.PathId -> r1 := @parameter0: montecarlo.PathId -> r0 := @this: montecarlo.PathId -> $r1 = r0.<montecarlo.PathId: java.lang.String name> -> if $r1 != null goto $r3 = r0.<montecarlo.PathId: java.lang.String name> -> $r3 = r0.<montecarlo.PathId: java.lang.String name> -> return $r3 -> $r2 = virtualinvoke r1.<montecarlo.PathId: java.lang.String get_name()>() -> r0.<montecarlo.PathId: java.lang.String name> = $r2 -> r0 := @this: montecarlo.PathId -> $i0 = r0.<montecarlo.PathId: int startDate> -> if $i0 != 0 goto $i1 = r0.<montecarlo.PathId: int startDate> -> $i1 = r0.<montecarlo.PathId: int startDate> -> return $i1 -> $i0 = virtualinvoke r1.<montecarlo.PathId: int get_startDate()>() -> r0.<montecarlo.PathId: int startDate> = $i0 -> r0 := @this: montecarlo.PathId -> $i0 = r0.<montecarlo.PathId: int endDate> -> if $i0 != 0 goto $i1 = r0.<montecarlo.PathId: int endDate> -> $i1 = r0.<montecarlo.PathId: int endDate> -> return $i1 -> $i1 = virtualinvoke r1.<montecarlo.PathId: int get_endDate()>() -> r0.<montecarlo.PathId: int endDate> = $i1 -> r0 := @this: montecarlo.PathId -> $d0 = r0.<montecarlo.PathId: double dTime> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.PathId: double dTime> -> $d1 = r0.<montecarlo.PathId: double dTime> -> return $d1 -> $d0 = virtualinvoke r1.<montecarlo.PathId: double get_dTime()>() -> r0.<montecarlo.PathId: double dTime> = $d0 -> return ->  End~~~10001
Start -> r0 := @this: montecarlo.PathId -> $d0 = r0.<montecarlo.PathId: double dTime> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.PathId: double dTime> -> $d1 = r0.<montecarlo.PathId: double dTime> -> return $d1 ->  End~~~60005
Start -> r0 := @this: montecarlo.ReturnPath -> virtualinvoke r0.<montecarlo.ReturnPath: void computeMean()>() -> r0 := @this: montecarlo.ReturnPath -> $i1 = r0.<montecarlo.ReturnPath: int nPathValue> -> if $i1 != 0 goto r0.<montecarlo.ReturnPath: double mean> = 0.0 -> r0.<montecarlo.ReturnPath: double mean> = 0.0 -> i0 = 1 -> goto [?= $i2 = r0.<montecarlo.ReturnPath: int nPathValue>] -> $i2 = r0.<montecarlo.ReturnPath: int nPathValue> -> if i0 < $i2 goto $d0 = r0.<montecarlo.ReturnPath: double mean> -> $d0 = r0.<montecarlo.ReturnPath: double mean> -> $r3 = r0.<montecarlo.ReturnPath: double[] pathValue> -> $d1 = $r3[i0] -> $d2 = $d0 + $d1 -> r0.<montecarlo.ReturnPath: double mean> = $d2 -> i0 = i0 + 1 -> $d3 = r0.<montecarlo.ReturnPath: double mean> -> $i3 = r0.<montecarlo.ReturnPath: int nPathValue> -> $d4 = (double) $i3 -> $d5 = $d4 - 1.0 -> $d6 = $d3 / $d5 -> r0.<montecarlo.ReturnPath: double mean> = $d6 -> return -> virtualinvoke r0.<montecarlo.ReturnPath: void computeVariance()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double mean> -> $b1 = $d0 cmpl #NaN -> if $b1 == 0 goto $r1 = new montecarlo.DemoException -> $i2 = r0.<montecarlo.ReturnPath: int nPathValue> -> if $i2 != 0 goto r0.<montecarlo.ReturnPath: double variance> = 0.0 -> r0.<montecarlo.ReturnPath: double variance> = 0.0 -> i0 = 1 -> goto [?= $i3 = r0.<montecarlo.ReturnPath: int nPathValue>] -> $i3 = r0.<montecarlo.ReturnPath: int nPathValue> -> if i0 < $i3 goto $d1 = r0.<montecarlo.ReturnPath: double variance> -> $d1 = r0.<montecarlo.ReturnPath: double variance> -> $r3 = r0.<montecarlo.ReturnPath: double[] pathValue> -> $d2 = $r3[i0] -> $d3 = r0.<montecarlo.ReturnPath: double mean> -> $d4 = $d2 - $d3 -> $r4 = r0.<montecarlo.ReturnPath: double[] pathValue> -> $d5 = $r4[i0] -> $d6 = r0.<montecarlo.ReturnPath: double mean> -> $d7 = $d5 - $d6 -> $d8 = $d4 * $d7 -> $d9 = $d1 + $d8 -> r0.<montecarlo.ReturnPath: double variance> = $d9 -> i0 = i0 + 1 -> $d10 = r0.<montecarlo.ReturnPath: double variance> -> $i4 = r0.<montecarlo.ReturnPath: int nPathValue> -> $d11 = (double) $i4 -> $d12 = $d11 - 1.0 -> $d13 = $d10 / $d12 -> r0.<montecarlo.ReturnPath: double variance> = $d13 -> return -> virtualinvoke r0.<montecarlo.ReturnPath: void computeExpectedReturnRate()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double mean> -> $d1 = virtualinvoke r0.<montecarlo.ReturnPath: double get_dTime()>() -> $d2 = $d0 / $d1 -> $d3 = r0.<montecarlo.ReturnPath: double volatility2> -> $d4 = 0.5 * $d3 -> $d5 = $d2 + $d4 -> r0.<montecarlo.ReturnPath: double expectedReturnRate> = $d5 -> return -> virtualinvoke r0.<montecarlo.ReturnPath: void computeVolatility()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double variance> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double variance> -> $d1 = r0.<montecarlo.ReturnPath: double variance> -> $d2 = virtualinvoke r0.<montecarlo.ReturnPath: double get_dTime()>() -> $d3 = $d1 / $d2 -> r0.<montecarlo.ReturnPath: double volatility2> = $d3 -> $d4 = r0.<montecarlo.ReturnPath: double volatility2> -> $d5 = staticinvoke <java.lang.Math: double sqrt(double)>($d4) -> r0.<montecarlo.ReturnPath: double volatility> = $d5 -> return -> return ->  End~~~18239478
Start -> $r2 = r0.<montecarlo.RatePath: double[] pathValue> -> if $r2 == null goto $r3 = new montecarlo.DemoException -> $i1 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> if $i1 != 0 goto $i2 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> $i2 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> r1 = newarray (double)[$i2] -> r1[0] = 0.0 -> i0 = 1 -> goto [?= $i4 = r0.<montecarlo.RatePath: int nAcceptedPathValue>] -> $i4 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> if i0 < $i4 goto $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $d0 = $r4[i0] -> $r5 = r0.<montecarlo.RatePath: double[] pathValue> -> $i3 = i0 - 1 -> $d1 = $r5[$i3] -> $d2 = $d0 / $d1 -> $d3 = staticinvoke <java.lang.Math: double log(double)>($d2) -> r1[i0] = $d3 -> i0 = i0 + 1 -> goto [?= $r13 = new montecarlo.ReturnPath] -> $r13 = new montecarlo.ReturnPath -> $i5 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> $i6 = <montecarlo.ReturnPath: int COMPOUNDED> -> specialinvoke $r13.<montecarlo.ReturnPath: void <init>(double[],int,int)>(r1, $i5, $i6) -> r14 = $r13 -> virtualinvoke r14.<montecarlo.ReturnPath: void copyInstanceVariables(montecarlo.PathId)>(r0) -> virtualinvoke r14.<montecarlo.ReturnPath: void estimatePath()>() -> return r14 ->  End~~~2379
Start -> virtualinvoke r3.<montecarlo.ReturnPath: void estimatePath()>() -> virtualinvoke r3.<montecarlo.ReturnPath: void dbgDumpFields()>() -> r0 := @this: montecarlo.ReturnPath -> specialinvoke r0.<montecarlo.PathId: void dbgDumpFields()>() -> return ->  End~~~1
Start -> virtualinvoke r2.<montecarlo.RatePath: void dbgDumpFields()>() -> r0 := @this: montecarlo.RatePath -> r3 = virtualinvoke r2.<montecarlo.RatePath: montecarlo.ReturnPath getReturnCompounded()>() -> virtualinvoke r3.<montecarlo.ReturnPath: double get_expectedReturnRate()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> $d1 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> return $d1 ->  End~~~1
Start -> r0 := @this: montecarlo.RatePath -> r1 := @parameter0: java.lang.String -> r2 := @parameter1: java.lang.String -> specialinvoke r0.<montecarlo.PathId: void <init>()>() -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = 0 -> $r3 = <montecarlo.RatePath: java.lang.String prompt> -> virtualinvoke r0.<montecarlo.RatePath: void set_prompt(java.lang.String)>($r3) -> $z0 = <montecarlo.RatePath: boolean DEBUG> -> virtualinvoke r0.<montecarlo.RatePath: void set_DEBUG(boolean)>($z0) -> specialinvoke r0.<montecarlo.RatePath: void readRatesFile(java.lang.String,java.lang.String)>(r1, r2) -> r0 := @this: montecarlo.RatePath -> r1 := @parameter0: java.lang.String -> r2 := @parameter1: java.lang.String -> $r3 = new java.io.File -> specialinvoke $r3.<java.io.File: void <init>(java.lang.String,java.lang.String)>(r1, r2) -> r4 = $r3 -> $z1 = virtualinvoke r4.<java.io.File: boolean canRead()>() -> if $z1 != 0 goto $r16 = new java.io.BufferedReader -> $r16 = new java.io.BufferedReader -> $r17 = new java.io.FileReader -> specialinvoke $r17.<java.io.FileReader: void <init>(java.io.File)>(r4) -> specialinvoke $r16.<java.io.BufferedReader: void <init>(java.io.Reader)>($r17) -> r5 = $r16 -> goto [?= i2 = 0] -> i2 = 0 -> b0 = 100 -> z0 = 0 -> $r21 = new java.util.Vector -> specialinvoke $r21.<java.util.Vector: void <init>(int)>(b0) -> r7 = $r21 -> goto [?= $r22 = virtualinvoke r5.<java.io.BufferedReader: java.lang.String readLine()>()] -> $r22 = virtualinvoke r5.<java.io.BufferedReader: java.lang.String readLine()>() -> r8 = $r22 -> if $r22 != null goto i2 = i2 + 1 -> i2 = i2 + 1 -> virtualinvoke r7.<java.util.Vector: void addElement(java.lang.Object)>(r8) -> goto [?= i3 = i2] -> i3 = i2 -> $r29 = newarray (double)[i3] -> r0.<montecarlo.RatePath: double[] pathValue> = $r29 -> $r30 = newarray (int)[i3] -> r0.<montecarlo.RatePath: int[] pathDate> = $r30 -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = 0 -> i4 = 0 -> r31 = virtualinvoke r7.<java.util.Vector: java.util.Enumeration elements()>() -> goto [?= $z2 = interfaceinvoke r31.<java.util.Enumeration: boolean hasMoreElements()>()] -> $z2 = interfaceinvoke r31.<java.util.Enumeration: boolean hasMoreElements()>() -> if $z2 != 0 goto $r32 = interfaceinvoke r31.<java.util.Enumeration: java.lang.Object nextElement()>() -> $r32 = interfaceinvoke r31.<java.util.Enumeration: java.lang.Object nextElement()>() -> r33 = (java.lang.String) $r32 -> r2 = $r1 -> virtualinvoke r3.<montecarlo.ReturnPath: double get_volatility()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double volatility> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double volatility> -> $d1 = r0.<montecarlo.ReturnPath: double volatility> -> return $d1 ->  End~~~2164
Start -> r0 := @this: montecarlo.PathId -> $r1 = r0.<montecarlo.PathId: java.lang.String name> -> if $r1 != null goto $r3 = r0.<montecarlo.PathId: java.lang.String name> -> $r3 = r0.<montecarlo.PathId: java.lang.String name> -> return $r3 ->  End~~~10001
Start -> r0 := @this: montecarlo.PathId -> $i0 = r0.<montecarlo.PathId: int startDate> -> if $i0 != 0 goto $i1 = r0.<montecarlo.PathId: int startDate> -> $i1 = r0.<montecarlo.PathId: int startDate> -> return $i1 ->  End~~~1
Start -> r0 := @this: montecarlo.PathId -> $i0 = r0.<montecarlo.PathId: int endDate> -> if $i0 != 0 goto $i1 = r0.<montecarlo.PathId: int endDate> -> $i1 = r0.<montecarlo.PathId: int endDate> -> return $i1 ->  End~~~1
Start -> r0 := @this: montecarlo.ReturnPath -> $i0 = r0.<montecarlo.ReturnPath: int returnDefinition> -> if $i0 != 0 goto $i1 = r0.<montecarlo.ReturnPath: int returnDefinition> -> $i1 = r0.<montecarlo.ReturnPath: int returnDefinition> -> return $i1 ->  End~~~1
Start -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> $d1 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> return $d1 ->  End~~~1
Start -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double volatility> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double volatility> -> $d1 = r0.<montecarlo.ReturnPath: double volatility> -> return $d1 ->  End~~~10001
Start -> r0 := @this: montecarlo.ToInitAllTasks -> r1 := @parameter0: montecarlo.ReturnPath -> i0 := @parameter1: int -> d0 := @parameter2: double -> specialinvoke r0.<java.lang.Object: void <init>()>() -> $r2 = virtualinvoke r1.<montecarlo.ReturnPath: java.lang.String get_name()>() -> r0.<montecarlo.ToInitAllTasks: java.lang.String name> = $r2 -> $i1 = virtualinvoke r1.<montecarlo.ReturnPath: int get_startDate()>() -> r0.<montecarlo.ToInitAllTasks: int startDate> = $i1 -> $i2 = virtualinvoke r1.<montecarlo.ReturnPath: int get_endDate()>() -> r0.<montecarlo.ToInitAllTasks: int endDate> = $i2 -> $d1 = virtualinvoke r1.<montecarlo.ReturnPath: double get_dTime()>() -> r0.<montecarlo.ToInitAllTasks: double dTime> = $d1 -> $i3 = virtualinvoke r1.<montecarlo.ReturnPath: int get_returnDefinition()>() -> r0.<montecarlo.ToInitAllTasks: int returnDefinition> = $i3 -> $d2 = virtualinvoke r1.<montecarlo.ReturnPath: double get_expectedReturnRate()>() -> r0.<montecarlo.ToInitAllTasks: double expectedReturnRate> = $d2 -> $d3 = virtualinvoke r1.<montecarlo.ReturnPath: double get_volatility()>() -> r0.<montecarlo.ToInitAllTasks: double volatility> = $d3 -> r0.<montecarlo.ToInitAllTasks: int nTimeSteps> = i0 -> r0.<montecarlo.ToInitAllTasks: double pathStartValue> = d0 -> return ->  End~~~1
Start -> r0 := @this: montecarlo.ToTask -> r1 := @parameter0: java.lang.String -> l0 := @parameter1: long -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<montecarlo.ToTask: java.lang.String header> = r1 -> r0.<montecarlo.ToTask: long randomSeed> = l0 -> return ->  End~~~10000
Start -> r4 = "MonteCarlo.PriceStock" -> $i1 = r0.<montecarlo.AppDemo: int nRunsMC> -> specialinvoke r0.<montecarlo.AppDemo: void initTasks(int)>($i1) -> r0 := @this: montecarlo.AppDemo -> i0 := @parameter0: int -> $r1 = new java.util.Vector -> specialinvoke $r1.<java.util.Vector: void <init>(int)>(i0) -> <montecarlo.AppDemo: java.util.Vector tasks> = $r1 -> i1 = 0 -> goto [?= (branch)] -> if i1 < i0 goto $r4 = new java.lang.StringBuilder -> $r4 = new java.lang.StringBuilder -> specialinvoke $r4.<java.lang.StringBuilder: void <init>(java.lang.String)>("MC run ") -> $r5 = staticinvoke <java.lang.String: java.lang.String valueOf(int)>(i1) -> $r6 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r5) -> r2 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.String toString()>() -> $r7 = new montecarlo.ToTask -> $l2 = (long) i1 -> $l3 = $l2 * 11L -> specialinvoke $r7.<montecarlo.ToTask: void <init>(java.lang.String,long)>(r2, $l3) -> r3 = $r7 -> $r8 = <montecarlo.AppDemo: java.util.Vector tasks> -> virtualinvoke $r8.<java.util.Vector: void addElement(java.lang.Object)>(r3) -> i1 = i1 + 1 -> return -> goto [?= return] -> return ->  End~~~9333
Start -> $i0 = r0.<montecarlo.AppDemo: int nTimeStepsMC> -> $d2 = r0.<montecarlo.AppDemo: double pathStartValue> -> specialinvoke $r7.<montecarlo.ToInitAllTasks: void <init>(montecarlo.ReturnPath,int,double)>(r3, $i0, $d2) -> <montecarlo.AppDemo: montecarlo.ToInitAllTasks initAllTasks> = $r7 -> return ->  End~~~1
Start -> r0 := @this: montecarlo.AppDemo -> <montecarlo.RatePath: boolean DEBUG> = 1 -> $r1 = new montecarlo.RatePath -> $r5 = r0.<montecarlo.AppDemo: java.lang.String dataDirname> -> $r6 = r0.<montecarlo.AppDemo: java.lang.String dataFilename> -> specialinvoke $r1.<montecarlo.RatePath: void <init>(java.lang.String,java.lang.String)>($r5, $r6) -> $r7 = new montecarlo.ToInitAllTasks -> return ->  End~~~1
Start -> r0 := @this: montecarlo.AppDemoThread -> i0 := @parameter0: int -> i1 := @parameter1: int -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<montecarlo.AppDemoThread: int id> = i0 -> r0.<montecarlo.AppDemoThread: int nRunsMC> = i1 -> return ->  End~~~1
Start -> <montecarlo.PriceStock: boolean DEBUG> = 1 -> <montecarlo.PriceStock: java.lang.String prompt> = "PriceStock> " -> return ->  End~~~1
Start -> <montecarlo.MonteCarloPath: boolean DEBUG> = 1 -> <montecarlo.MonteCarloPath: java.lang.String prompt> = "MonteCarloPath> " -> $i0 = <montecarlo.RatePath: int DATUMFIELD> -> <montecarlo.MonteCarloPath: int DATUMFIELD> = $i0 -> return ->  End~~~1
Start -> r0 := @this: montecarlo.MonteCarloPath -> specialinvoke r0.<montecarlo.PathId: void <init>()>() -> r0.<montecarlo.MonteCarloPath: int returnDefinition> = 0 -> r0.<montecarlo.MonteCarloPath: double expectedReturnRate> = #NaN -> r0.<montecarlo.MonteCarloPath: double volatility> = #NaN -> r0.<montecarlo.MonteCarloPath: int nTimeSteps> = 0 -> r0.<montecarlo.MonteCarloPath: double pathStartValue> = #NaN -> $r1 = <montecarlo.MonteCarloPath: java.lang.String prompt> -> virtualinvoke r0.<montecarlo.MonteCarloPath: void set_prompt(java.lang.String)>($r1) -> $z0 = <montecarlo.MonteCarloPath: boolean DEBUG> -> virtualinvoke r0.<montecarlo.MonteCarloPath: void set_DEBUG(boolean)>($z0) -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.PriceStock -> specialinvoke r0.<montecarlo.Universal: void <init>()>() -> r0.<montecarlo.PriceStock: long randomSeed> = -1L -> r0.<montecarlo.PriceStock: double pathStartValue> = #NaN -> r0.<montecarlo.PriceStock: double expectedReturnRate> = #NaN -> r0.<montecarlo.PriceStock: double volatility> = #NaN -> r0.<montecarlo.PriceStock: double volatility2> = #NaN -> r0.<montecarlo.PriceStock: double finalStockPrice> = #NaN -> $r1 = new montecarlo.MonteCarloPath -> specialinvoke $r1.<montecarlo.MonteCarloPath: void <init>()>() -> r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> = $r1 -> $r2 = <montecarlo.PriceStock: java.lang.String prompt> -> virtualinvoke r0.<montecarlo.PriceStock: void set_prompt(java.lang.String)>($r2) -> $z0 = <montecarlo.PriceStock: boolean DEBUG> -> virtualinvoke r0.<montecarlo.PriceStock: void set_DEBUG(boolean)>($z0) -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.ToInitAllTasks -> $r1 = r0.<montecarlo.ToInitAllTasks: java.lang.String name> -> return $r1 ->  End~~~10000
Start -> r0 := @this: montecarlo.ToInitAllTasks -> $i0 = r0.<montecarlo.ToInitAllTasks: int startDate> -> return $i0 ->  End~~~10000
Start -> r0 := @this: montecarlo.ToInitAllTasks -> $i0 = r0.<montecarlo.ToInitAllTasks: int endDate> -> return $i0 ->  End~~~10000
Start -> r0 := @this: montecarlo.ToInitAllTasks -> $d0 = r0.<montecarlo.ToInitAllTasks: double dTime> -> return $d0 ->  End~~~10000
Start -> r0 := @this: montecarlo.ToInitAllTasks -> $i0 = r0.<montecarlo.ToInitAllTasks: int returnDefinition> -> return $i0 ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> i0 := @parameter0: int -> r0.<montecarlo.MonteCarloPath: int returnDefinition> = i0 -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.ToInitAllTasks -> $d0 = r0.<montecarlo.ToInitAllTasks: double expectedReturnRate> -> return $d0 ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> d0 := @parameter0: double -> r0.<montecarlo.MonteCarloPath: double expectedReturnRate> = d0 -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.ToInitAllTasks -> $d0 = r0.<montecarlo.ToInitAllTasks: double volatility> -> return $d0 ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> d0 := @parameter0: double -> r0.<montecarlo.MonteCarloPath: double volatility> = d0 -> return ->  End~~~10000
Start -> $i0 = r0.<montecarlo.ToInitAllTasks: int nTimeSteps> -> return $i0 ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> i0 := @parameter0: int -> r0.<montecarlo.MonteCarloPath: int nTimeSteps> = i0 -> return ->  End~~~10000
Start -> $d0 = r0.<montecarlo.ToInitAllTasks: double pathStartValue> -> return $d0 ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> d0 := @parameter0: double -> r0.<montecarlo.MonteCarloPath: double pathStartValue> = d0 -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> r1 := @parameter0: double[] -> r0.<montecarlo.MonteCarloPath: double[] pathValue> = r1 -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> r1 := @parameter0: double[] -> r0.<montecarlo.MonteCarloPath: double[] fluctuations> = r1 -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.PriceStock -> r1 := @parameter0: java.lang.Object -> r2 = (montecarlo.ToInitAllTasks) r1 -> $r3 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $r4 = virtualinvoke r2.<montecarlo.ToInitAllTasks: java.lang.String get_name()>() -> virtualinvoke $r3.<montecarlo.MonteCarloPath: void set_name(java.lang.String)>($r4) -> $r5 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $i1 = virtualinvoke r2.<montecarlo.ToInitAllTasks: int get_startDate()>() -> virtualinvoke $r5.<montecarlo.MonteCarloPath: void set_startDate(int)>($i1) -> $r6 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $i2 = virtualinvoke r2.<montecarlo.ToInitAllTasks: int get_endDate()>() -> virtualinvoke $r6.<montecarlo.MonteCarloPath: void set_endDate(int)>($i2) -> $r7 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $d0 = virtualinvoke r2.<montecarlo.ToInitAllTasks: double get_dTime()>() -> virtualinvoke $r7.<montecarlo.MonteCarloPath: void set_dTime(double)>($d0) -> $r8 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $i3 = virtualinvoke r2.<montecarlo.ToInitAllTasks: int get_returnDefinition()>() -> virtualinvoke $r8.<montecarlo.MonteCarloPath: void set_returnDefinition(int)>($i3) -> $r9 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $d1 = virtualinvoke r2.<montecarlo.ToInitAllTasks: double get_expectedReturnRate()>() -> virtualinvoke $r9.<montecarlo.MonteCarloPath: void set_expectedReturnRate(double)>($d1) -> $r10 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $d2 = virtualinvoke r2.<montecarlo.ToInitAllTasks: double get_volatility()>() -> virtualinvoke $r10.<montecarlo.MonteCarloPath: void set_volatility(double)>($d2) -> r0 := @this: montecarlo.ToInitAllTasks -> i0 = virtualinvoke r2.<montecarlo.ToInitAllTasks: int get_nTimeSteps()>() -> $r11 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> virtualinvoke $r11.<montecarlo.MonteCarloPath: void set_nTimeSteps(int)>(i0) -> r0 := @this: montecarlo.ToInitAllTasks -> $d3 = virtualinvoke r2.<montecarlo.ToInitAllTasks: double get_pathStartValue()>() -> r0.<montecarlo.PriceStock: double pathStartValue> = $d3 -> $r12 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $d4 = r0.<montecarlo.PriceStock: double pathStartValue> -> virtualinvoke $r12.<montecarlo.MonteCarloPath: void set_pathStartValue(double)>($d4) -> $r13 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $r14 = newarray (double)[i0] -> virtualinvoke $r13.<montecarlo.MonteCarloPath: void set_pathValue(double[])>($r14) -> $r15 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $r16 = newarray (double)[i0] -> virtualinvoke $r15.<montecarlo.MonteCarloPath: void set_fluctuations(double[])>($r16) -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.ToTask -> $r1 = r0.<montecarlo.ToTask: java.lang.String header> -> return $r1 ->  End~~~10000
Start -> r0 := @this: montecarlo.ToTask -> $l0 = r0.<montecarlo.ToTask: long randomSeed> -> return $l0 ->  End~~~10000
Start -> r0 := @this: montecarlo.PriceStock -> r1 := @parameter0: java.lang.Object -> r2 = (montecarlo.ToTask) r1 -> $r3 = virtualinvoke r2.<montecarlo.ToTask: java.lang.String get_header()>() -> r0.<montecarlo.PriceStock: java.lang.String taskHeader> = $r3 -> $l0 = virtualinvoke r2.<montecarlo.ToTask: long get_randomSeed()>() -> r0.<montecarlo.PriceStock: long randomSeed> = $l0 -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> l0 := @parameter0: long -> $i2 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> $r2 = r0.<montecarlo.MonteCarloPath: double[] fluctuations> -> $i3 = lengthof $r2 -> if $i2 <= $i3 goto $b4 = l0 cmp -1L -> $b4 = l0 cmp -1L -> if $b4 != 0 goto $r5 = new java.util.Random -> $r5 = new java.util.Random -> specialinvoke $r5.<java.util.Random: void <init>(long)>(l0) -> r1 = $r5 -> $d5 = r0.<montecarlo.MonteCarloPath: double expectedReturnRate> -> $d6 = r0.<montecarlo.MonteCarloPath: double volatility> -> $d7 = 0.5 * $d6 -> $d8 = r0.<montecarlo.MonteCarloPath: double volatility> -> $d9 = $d7 * $d8 -> $d10 = $d5 - $d9 -> $d11 = virtualinvoke r0.<montecarlo.MonteCarloPath: double get_dTime()>() -> d0 = $d10 * $d11 -> $d12 = r0.<montecarlo.MonteCarloPath: double volatility> -> $d13 = virtualinvoke r0.<montecarlo.MonteCarloPath: double get_dTime()>() -> $d14 = staticinvoke <java.lang.Math: double sqrt(double)>($d13) -> d1 = $d12 * $d14 -> d2 = 0.0 -> d3 = 0.0 -> i1 = 0 -> goto [?= $i5 = r0.<montecarlo.MonteCarloPath: int nTimeSteps>] -> $i5 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> if i1 < $i5 goto d4 = virtualinvoke r1.<java.util.Random: double nextGaussian()>() -> d4 = virtualinvoke r1.<java.util.Random: double nextGaussian()>() -> d2 = d2 + d4 -> $d15 = d4 * d4 -> d3 = d3 + $d15 -> $r6 = r0.<montecarlo.MonteCarloPath: double[] fluctuations> -> $d16 = d1 * d4 -> $d17 = d0 + $d16 -> $r6[i1] = $d17 -> i1 = i1 + 1 -> $i6 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> $d18 = (double) $i6 -> d19 = d2 / $d18 -> $i7 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> $d20 = (double) $i7 -> d21 = d3 / $d20 -> return ->  End~~~9160000
Start -> r0 := @this: montecarlo.MonteCarloPath -> d0 := @parameter0: double -> $r1 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> $r1[0] = d0 -> $i1 = r0.<montecarlo.MonteCarloPath: int returnDefinition> -> $i2 = <montecarlo.ReturnPath: int COMPOUNDED> -> if $i1 == $i2 goto i0 = 1 -> i0 = 1 -> goto [?= $i6 = r0.<montecarlo.MonteCarloPath: int nTimeSteps>] -> $i6 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> if i0 < $i6 goto $r2 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> $r2 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> $r3 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> $i5 = i0 - 1 -> $d1 = $r3[$i5] -> $r4 = r0.<montecarlo.MonteCarloPath: double[] fluctuations> -> $d2 = $r4[i0] -> $d3 = staticinvoke <java.lang.Math: double exp(double)>($d2) -> $d4 = $d1 * $d3 -> $r2[i0] = $d4 -> i0 = i0 + 1 -> goto [?= return] -> return ->  End~~~9220000
Start -> $i0 = r0.<montecarlo.PathId: int startDate> -> if $i0 != 0 goto $i1 = r0.<montecarlo.PathId: int startDate> -> $i1 = r0.<montecarlo.PathId: int startDate> -> return $i1 ->  End~~~10000
Start -> $i0 = r0.<montecarlo.PathId: int endDate> -> if $i0 != 0 goto $i1 = r0.<montecarlo.PathId: int endDate> -> $i1 = r0.<montecarlo.PathId: int endDate> -> return $i1 ->  End~~~10000
Start -> $d0 = r0.<montecarlo.PathId: double dTime> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.PathId: double dTime> -> $d1 = r0.<montecarlo.PathId: double dTime> -> return $d1 ->  End~~~10000
Start -> $r1 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> if $r1 != null goto $r3 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> $r3 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> return $r3 ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> $i0 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> if $i0 != 0 goto $i1 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> $i1 = r0.<montecarlo.MonteCarloPath: int nTimeSteps> -> return $i1 ->  End~~~10000
Start -> r0 := @this: montecarlo.PathId -> i0 := @parameter0: int -> r0.<montecarlo.PathId: int endDate> = i0 -> return -> r0 := @this: montecarlo.PathId -> $d0 = virtualinvoke r1.<montecarlo.MonteCarloPath: double get_dTime()>() -> virtualinvoke r0.<montecarlo.RatePath: void set_dTime(double)>($d0) -> r0 := @this: montecarlo.MonteCarloPath -> $r3 = virtualinvoke r1.<montecarlo.MonteCarloPath: double[] get_pathValue()>() -> r0.<montecarlo.RatePath: double[] pathValue> = $r3 -> $i2 = virtualinvoke r1.<montecarlo.MonteCarloPath: int get_nTimeSteps()>() -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = $i2 -> $i3 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> $r4 = newarray (int)[$i3] -> r0.<montecarlo.RatePath: int[] pathDate> = $r4 -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.PathId -> i0 := @parameter0: int -> r0.<montecarlo.PathId: int startDate> = i0 -> return -> r0 := @this: montecarlo.PathId -> $i1 = virtualinvoke r1.<montecarlo.MonteCarloPath: int get_endDate()>() -> virtualinvoke r0.<montecarlo.RatePath: void set_endDate(int)>($i1) -> r1 = $r5 -> r0 := @this: montecarlo.RatePath -> $r2 = r0.<montecarlo.RatePath: double[] pathValue> -> if $r2 == null goto $r3 = new montecarlo.DemoException -> $i1 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> if $i1 != 0 goto $i2 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> $i2 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> r1 = newarray (double)[$i2] -> r1[0] = 0.0 -> i0 = 1 -> goto [?= $i4 = r0.<montecarlo.RatePath: int nAcceptedPathValue>] -> $i4 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> if i0 < $i4 goto $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $d0 = $r4[i0] -> $r5 = r0.<montecarlo.RatePath: double[] pathValue> -> $i3 = i0 - 1 -> $d1 = $r5[$i3] -> $d2 = $d0 / $d1 -> $d3 = staticinvoke <java.lang.Math: double log(double)>($d2) -> r1[i0] = $d3 -> i0 = i0 + 1 -> goto [?= $r13 = new montecarlo.ReturnPath] -> $r13 = new montecarlo.ReturnPath -> $i5 = r0.<montecarlo.RatePath: int nAcceptedPathValue> -> $i6 = <montecarlo.ReturnPath: int COMPOUNDED> -> specialinvoke $r13.<montecarlo.ReturnPath: void <init>(double[],int,int)>(r1, $i5, $i6) -> r14 = $r13 -> virtualinvoke r14.<montecarlo.ReturnPath: void copyInstanceVariables(montecarlo.PathId)>(r0) -> virtualinvoke r14.<montecarlo.ReturnPath: void estimatePath()>() -> return r14 ->  End~~~9160000
Start -> r0 := @this: montecarlo.ReturnPath -> virtualinvoke r0.<montecarlo.ReturnPath: void computeMean()>() -> r0 := @this: montecarlo.ReturnPath -> $i1 = r0.<montecarlo.ReturnPath: int nPathValue> -> if $i1 != 0 goto r0.<montecarlo.ReturnPath: double mean> = 0.0 -> r0.<montecarlo.ReturnPath: double mean> = 0.0 -> i0 = 1 -> goto [?= $i2 = r0.<montecarlo.ReturnPath: int nPathValue>] -> $i2 = r0.<montecarlo.ReturnPath: int nPathValue> -> if i0 < $i2 goto $d0 = r0.<montecarlo.ReturnPath: double mean> -> $d0 = r0.<montecarlo.ReturnPath: double mean> -> $r3 = r0.<montecarlo.ReturnPath: double[] pathValue> -> $d1 = $r3[i0] -> $d2 = $d0 + $d1 -> r0.<montecarlo.ReturnPath: double mean> = $d2 -> i0 = i0 + 1 -> $d3 = r0.<montecarlo.ReturnPath: double mean> -> $i3 = r0.<montecarlo.ReturnPath: int nPathValue> -> $d4 = (double) $i3 -> $d5 = $d4 - 1.0 -> $d6 = $d3 / $d5 -> r0.<montecarlo.ReturnPath: double mean> = $d6 -> return -> virtualinvoke r0.<montecarlo.ReturnPath: void computeVariance()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double mean> -> $b1 = $d0 cmpl #NaN -> if $b1 == 0 goto $r1 = new montecarlo.DemoException -> $i2 = r0.<montecarlo.ReturnPath: int nPathValue> -> if $i2 != 0 goto r0.<montecarlo.ReturnPath: double variance> = 0.0 -> r0.<montecarlo.ReturnPath: double variance> = 0.0 -> i0 = 1 -> goto [?= $i3 = r0.<montecarlo.ReturnPath: int nPathValue>] -> $i3 = r0.<montecarlo.ReturnPath: int nPathValue> -> if i0 < $i3 goto $d1 = r0.<montecarlo.ReturnPath: double variance> -> $d1 = r0.<montecarlo.ReturnPath: double variance> -> $r3 = r0.<montecarlo.ReturnPath: double[] pathValue> -> $d2 = $r3[i0] -> $d3 = r0.<montecarlo.ReturnPath: double mean> -> $d4 = $d2 - $d3 -> $r4 = r0.<montecarlo.ReturnPath: double[] pathValue> -> $d5 = $r4[i0] -> $d6 = r0.<montecarlo.ReturnPath: double mean> -> $d7 = $d5 - $d6 -> $d8 = $d4 * $d7 -> $d9 = $d1 + $d8 -> r0.<montecarlo.ReturnPath: double variance> = $d9 -> i0 = i0 + 1 -> $d10 = r0.<montecarlo.ReturnPath: double variance> -> $i4 = r0.<montecarlo.ReturnPath: int nPathValue> -> $d11 = (double) $i4 -> $d12 = $d11 - 1.0 -> $d13 = $d10 / $d12 -> r0.<montecarlo.ReturnPath: double variance> = $d13 -> return -> virtualinvoke r0.<montecarlo.ReturnPath: void computeExpectedReturnRate()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double mean> -> $d1 = virtualinvoke r0.<montecarlo.ReturnPath: double get_dTime()>() -> $d2 = $d0 / $d1 -> $d3 = r0.<montecarlo.ReturnPath: double volatility2> -> $d4 = 0.5 * $d3 -> $d5 = $d2 + $d4 -> r0.<montecarlo.ReturnPath: double expectedReturnRate> = $d5 -> return -> virtualinvoke r0.<montecarlo.ReturnPath: void computeVolatility()>() -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double variance> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double variance> -> $d1 = r0.<montecarlo.ReturnPath: double variance> -> $d2 = virtualinvoke r0.<montecarlo.ReturnPath: double get_dTime()>() -> $d3 = $d1 / $d2 -> r0.<montecarlo.ReturnPath: double volatility2> = $d3 -> $d4 = r0.<montecarlo.ReturnPath: double volatility2> -> $d5 = staticinvoke <java.lang.Math: double sqrt(double)>($d4) -> r0.<montecarlo.ReturnPath: double volatility> = $d5 -> return -> return -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> $d1 = r0.<montecarlo.ReturnPath: double expectedReturnRate> -> return $d1 ->  End~~~18230000
Start -> r0 := @this: montecarlo.ReturnPath -> $d0 = r0.<montecarlo.ReturnPath: double volatility2> -> $b0 = $d0 cmpl #NaN -> if $b0 != 0 goto $d1 = r0.<montecarlo.ReturnPath: double volatility2> -> $d1 = r0.<montecarlo.ReturnPath: double volatility2> -> return $d1 ->  End~~~10000
Start -> r0 := @this: montecarlo.RatePath -> $r1 = r0.<montecarlo.RatePath: double[] pathValue> -> $i0 = lengthof $r1 -> $i1 = $i0 - 1 -> r0 := @this: montecarlo.RatePath -> i0 := @parameter0: int -> $r1 = r0.<montecarlo.RatePath: double[] pathValue> -> $d0 = $r1[i0] -> return $d0 -> $d0 = virtualinvoke r0.<montecarlo.RatePath: double getPathValue(int)>($i1) -> return $d0 ->  End~~~10000
Start -> r0 := @this: montecarlo.MonteCarloPath -> $r1 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> if $r1 != null goto $r3 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> $r3 = r0.<montecarlo.MonteCarloPath: double[] pathValue> -> return $r3 ->  End~~~10000
Start -> r0.<montecarlo.PriceStock: double finalStockPrice> = $d4 -> $r7 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $r8 = virtualinvoke $r7.<montecarlo.MonteCarloPath: double[] get_pathValue()>() -> r0.<montecarlo.PriceStock: double[] pathValue> = $r8 -> goto [?= return] -> return ->  End~~~10000
Start -> r0 := @this: montecarlo.ToResult -> r1 := @parameter0: java.lang.String -> d0 := @parameter1: double -> d1 := @parameter2: double -> d2 := @parameter3: double -> d3 := @parameter4: double -> r2 := @parameter5: double[] -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<montecarlo.ToResult: double expectedReturnRate> = #NaN -> r0.<montecarlo.ToResult: double volatility> = #NaN -> r0.<montecarlo.ToResult: double volatility2> = #NaN -> r0.<montecarlo.ToResult: double finalStockPrice> = #NaN -> r0.<montecarlo.ToResult: java.lang.String header> = r1 -> r0.<montecarlo.ToResult: double expectedReturnRate> = d0 -> r0.<montecarlo.ToResult: double volatility> = d1 -> r0.<montecarlo.ToResult: double volatility2> = d2 -> r0.<montecarlo.ToResult: double finalStockPrice> = d3 -> r0.<montecarlo.ToResult: double[] pathValue> = r2 -> return ->  End~~~10000
Start -> r0.<montecarlo.PriceStock: double expectedReturnRate> = $d1 -> $d2 = virtualinvoke r2.<montecarlo.ReturnPath: double get_volatility()>() -> r0.<montecarlo.PriceStock: double volatility> = $d2 -> $d3 = virtualinvoke r2.<montecarlo.ReturnPath: double get_volatility2()>() -> r0.<montecarlo.PriceStock: double volatility2> = $d3 -> $d4 = virtualinvoke r1.<montecarlo.RatePath: double getEndPathValue()>() -> $r6 = <montecarlo.AppDemo: java.util.Vector results> -> r0 := @this: montecarlo.PriceStock -> $r1 = new java.lang.StringBuilder -> specialinvoke $r1.<java.lang.StringBuilder: void <init>(java.lang.String)>("Result of task with Header=") -> $r4 = r0.<montecarlo.PriceStock: java.lang.String taskHeader> -> $r5 = virtualinvoke $r1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r4) -> $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(": randomSeed=") -> $l0 = r0.<montecarlo.PriceStock: long randomSeed> -> $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(long)>($l0) -> $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(": pathStartValue=") -> $d0 = r0.<montecarlo.PriceStock: double pathStartValue> -> $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d0) -> r2 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.String toString()>() -> $r10 = new montecarlo.ToResult -> $d1 = r0.<montecarlo.PriceStock: double expectedReturnRate> -> $d2 = r0.<montecarlo.PriceStock: double volatility> -> $d3 = r0.<montecarlo.PriceStock: double volatility2> -> $d4 = r0.<montecarlo.PriceStock: double finalStockPrice> -> $r11 = r0.<montecarlo.PriceStock: double[] pathValue> -> specialinvoke $r10.<montecarlo.ToResult: void <init>(java.lang.String,double,double,double,double,double[])>(r2, $d1, $d2, $d3, $d4, $r11) -> r3 = $r10 -> return r3 ->  End~~~10000
Start -> virtualinvoke $r6.<java.util.Vector: void addElement(java.lang.Object)>($r7) -> i4 = i4 + 1 -> if i4 < i3 goto $r2 = new montecarlo.PriceStock -> return ->  End~~~1
Start -> goto [?= $i8 = <montecarlo.JGFMonteCarloBench: int nthreads>] -> $i8 = <montecarlo.JGFMonteCarloBench: int nthreads> -> if i7 < $i8 goto $r11 = r3[i7] -> return ->  End~~~1
Start -> virtualinvoke r2.<montecarlo.ReturnPath: void estimatePath()>() -> $d1 = virtualinvoke r2.<montecarlo.ReturnPath: double get_expectedReturnRate()>() -> $r7 = virtualinvoke r1.<montecarlo.PriceStock: java.lang.Object getResult()>() -> i7 = 1 -> return ->  End~~~1
Start -> r0 := @this: jgfutil.JGFTimer -> $d0 = r0.<jgfutil.JGFTimer: double time> -> $l0 = staticinvoke <java.lang.System: long currentTimeMillis()>() -> $l1 = r0.<jgfutil.JGFTimer: long start_time> -> $l2 = $l0 - $l1 -> $d1 = (double) $l2 -> $d2 = $d1 / 1000.0 -> $d3 = $d0 + $d2 -> r0.<jgfutil.JGFTimer: double time> = $d3 -> $z0 = r0.<jgfutil.JGFTimer: boolean on> -> if $z0 != 0 goto $l3 = r0.<jgfutil.JGFTimer: long calls> -> $l3 = r0.<jgfutil.JGFTimer: long calls> -> $l4 = $l3 + 1L -> r0.<jgfutil.JGFTimer: long calls> = $l4 -> r0.<jgfutil.JGFTimer: boolean on> = 0 -> return ->  End~~~2
Start -> r0 := @parameter0: java.lang.String -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void stop()>() -> goto [?= return] -> return ->  End~~~2
Start -> r0 := @this: montecarlo.RatePath -> i0 := @parameter0: int -> r1 := @parameter1: java.lang.String -> i1 := @parameter2: int -> i2 := @parameter3: int -> d0 := @parameter4: double -> specialinvoke r0.<montecarlo.PathId: void <init>()>() -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = 0 -> virtualinvoke r0.<montecarlo.RatePath: void set_name(java.lang.String)>(r1) -> virtualinvoke r0.<montecarlo.RatePath: void set_startDate(int)>(i1) -> virtualinvoke r0.<montecarlo.RatePath: void set_endDate(int)>(i2) -> virtualinvoke r0.<montecarlo.RatePath: void set_dTime(double)>(d0) -> $r2 = <montecarlo.RatePath: java.lang.String prompt> -> virtualinvoke r0.<montecarlo.RatePath: void set_prompt(java.lang.String)>($r2) -> $z0 = <montecarlo.RatePath: boolean DEBUG> -> virtualinvoke r0.<montecarlo.RatePath: void set_DEBUG(boolean)>($z0) -> $r3 = newarray (double)[i0] -> r0.<montecarlo.RatePath: double[] pathValue> = $r3 -> $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $i3 = lengthof $r4 -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = $i3 -> return ->  End~~~1
Start -> r0 := @this: montecarlo.ToResult -> $r1 = r0.<montecarlo.ToResult: double[] pathValue> -> return $r1 ->  End~~~10000
Start -> r0 := @this: montecarlo.RatePath -> r1 := @parameter0: double[] -> $r2 = r0.<montecarlo.RatePath: double[] pathValue> -> $i1 = lengthof $r2 -> $i2 = lengthof r1 -> if $i1 == $i2 goto i0 = 0 -> i0 = 0 -> goto [?= $r5 = r0.<montecarlo.RatePath: double[] pathValue>] -> $r5 = r0.<montecarlo.RatePath: double[] pathValue> -> $i4 = lengthof $r5 -> if i0 < $i4 goto $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $d0 = $r4[i0] -> $d1 = r1[i0] -> $d2 = $d0 + $d1 -> $r4[i0] = $d2 -> i0 = i0 + 1 -> return ->  End~~~9000000
Start -> $d0 = r0.<montecarlo.ToResult: double expectedReturnRate> -> return $d0 ->  End~~~10000
Start -> r0 := @this: montecarlo.ToResult -> $d0 = r0.<montecarlo.ToResult: double volatility> -> return $d0 ->  End~~~10000
Start -> r0 := @this: montecarlo.RatePath -> d0 := @parameter0: double -> $r1 = r0.<montecarlo.RatePath: double[] pathValue> -> if $r1 != null goto i0 = 0 -> i0 = 0 -> goto [?= $r4 = r0.<montecarlo.RatePath: double[] pathValue>] -> $r4 = r0.<montecarlo.RatePath: double[] pathValue> -> $i2 = lengthof $r4 -> if i0 < $i2 goto $r3 = r0.<montecarlo.RatePath: double[] pathValue> -> $r3 = r0.<montecarlo.RatePath: double[] pathValue> -> $d1 = $r3[i0] -> $d2 = $d1 * d0 -> $r3[i0] = $d2 -> i0 = i0 + 1 -> return ->  End~~~889
Start -> r0 := @this: montecarlo.AppDemo -> specialinvoke r0.<montecarlo.AppDemo: void processResults()>() -> r0 := @this: montecarlo.AppDemo -> d0 = 0.0 -> d1 = 0.0 -> d2 = 0.0 -> d3 = 0.0 -> $i1 = r0.<montecarlo.AppDemo: int nRunsMC> -> $r1 = <montecarlo.AppDemo: java.util.Vector results> -> $i2 = virtualinvoke $r1.<java.util.Vector: int size()>() -> if $i1 == $i2 goto $r4 = new montecarlo.RatePath -> $r4 = new montecarlo.RatePath -> $i3 = r0.<montecarlo.AppDemo: int nTimeStepsMC> -> $d4 = r0.<montecarlo.AppDemo: double dTime> -> specialinvoke $r4.<montecarlo.RatePath: void <init>(int,java.lang.String,int,int,double)>($i3, "MC", 19990109, 19991231, $d4) -> r2 = $r4 -> i0 = 0 -> goto [?= $i6 = r0.<montecarlo.AppDemo: int nRunsMC>] -> $i6 = r0.<montecarlo.AppDemo: int nRunsMC> -> if i0 < $i6 goto $r5 = <montecarlo.AppDemo: java.util.Vector results> -> $r5 = <montecarlo.AppDemo: java.util.Vector results> -> $r6 = virtualinvoke $r5.<java.util.Vector: java.lang.Object elementAt(int)>(i0) -> r3 = (montecarlo.ToResult) $r6 -> $r7 = virtualinvoke r3.<montecarlo.ToResult: double[] get_pathValue()>() -> virtualinvoke r2.<montecarlo.RatePath: void inc_pathValue(double[])>($r7) -> r0 := @this: montecarlo.ToResult -> $d5 = virtualinvoke r3.<montecarlo.ToResult: double get_expectedReturnRate()>() -> d0 = d0 + $d5 -> $d6 = virtualinvoke r3.<montecarlo.ToResult: double get_volatility()>() -> d1 = d1 + $d6 -> $i4 = i0 + 1 -> $d7 = (double) $i4 -> d8 = d0 / $d7 -> $i5 = i0 + 1 -> $d9 = (double) $i5 -> d10 = d1 / $d9 -> i0 = i0 + 1 -> $i7 = r0.<montecarlo.AppDemo: int nRunsMC> -> $d11 = (double) $i7 -> $d12 = 1.0 / $d11 -> virtualinvoke r2.<montecarlo.RatePath: void inc_pathValue(double)>($d12) -> $i8 = r0.<montecarlo.AppDemo: int nRunsMC> -> $d13 = (double) $i8 -> d14 = d0 / $d13 -> $i9 = r0.<montecarlo.AppDemo: int nRunsMC> -> $d15 = (double) $i9 -> d16 = d1 / $d15 -> <montecarlo.AppDemo: double JGFavgExpectedReturnRateMC> = d14 -> return -> goto [?= return] -> return ->  End~~~9500
Start -> r0 := @this: montecarlo.CallAppDemo -> $r1 = r0.<montecarlo.CallAppDemo: montecarlo.AppDemo ap> -> virtualinvoke $r1.<montecarlo.AppDemo: void processSerial()>() -> return ->  End~~~1
Start -> r0 := @this: montecarlo.PathId -> r1 := @parameter0: java.lang.String -> r0.<montecarlo.PathId: java.lang.String name> = r1 -> return -> r0 := @this: montecarlo.PathId -> $i0 = virtualinvoke r1.<montecarlo.MonteCarloPath: int get_startDate()>() -> virtualinvoke r0.<montecarlo.RatePath: void set_startDate(int)>($i0) -> r2 = virtualinvoke r1.<montecarlo.RatePath: montecarlo.ReturnPath getReturnCompounded()>() -> staticinvoke <jgfutil.JGFInstrumentor: void stopTimer(java.lang.String)>("Section3:MonteCarlo:Run") -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void presults()>() -> return ->  End~~~1
Start -> r0 := @this: jgfutil.JGFTimer -> d0 := @parameter0: double -> $d1 = r0.<jgfutil.JGFTimer: double opcount> -> $d2 = $d1 + d0 -> r0.<jgfutil.JGFTimer: double opcount> = $d2 -> return ->  End~~~2
Start -> r0 := @parameter0: java.lang.String -> d0 := @parameter1: double -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void addops(double)>(d0) -> goto [?= return] -> return ->  End~~~2
Start -> r0 := @this: jgfutil.JGFTimer -> $r1 = r0.<jgfutil.JGFTimer: java.lang.String opname> -> $z0 = virtualinvoke $r1.<java.lang.String: boolean equals(java.lang.Object)>("") -> if $z0 == 0 goto $i0 = r0.<jgfutil.JGFTimer: int size> -> $i0 = r0.<jgfutil.JGFTimer: int size> -> $r10 = <java.lang.System: java.io.PrintStream out> -> $r11 = new java.lang.StringBuilder -> $r12 = r0.<jgfutil.JGFTimer: java.lang.String name> -> $r13 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>($r12) -> specialinvoke $r11.<java.lang.StringBuilder: void <init>(java.lang.String)>($r13) -> $r14 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(":SizeA") -> $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\t") -> $d1 = r0.<jgfutil.JGFTimer: double time> -> $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d1) -> $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" (s) \t ") -> r0 := @this: jgfutil.JGFTimer -> $d0 = r0.<jgfutil.JGFTimer: double opcount> -> $d1 = r0.<jgfutil.JGFTimer: double time> -> $d2 = $d0 / $d1 -> return $d2 -> $d2 = virtualinvoke r0.<jgfutil.JGFTimer: double perf()>() -> $f0 = (float) $d2 -> $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(float)>($f0) -> $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\t") -> $r20 = virtualinvoke $r19.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" (") -> $r21 = r0.<jgfutil.JGFTimer: java.lang.String opname> -> $r22 = virtualinvoke $r20.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r21) -> $r23 = virtualinvoke $r22.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("/s)") -> $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.String toString()>() -> virtualinvoke $r10.<java.io.PrintStream: void println(java.lang.String)>($r24) -> goto [?= return] -> return ->  End~~~2
Start -> return ->  End~~~2
Start -> r0 := @parameter0: java.lang.String -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void print()>() -> goto [?= return] -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void print()>() -> goto [?= return] -> staticinvoke <jgfutil.JGFInstrumentor: void printTimer(java.lang.String)>("Section3:MonteCarlo:Total") -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String[] -> $i1 = lengthof r0 -> if $i1 == 0 goto $r3 = <java.lang.System: java.io.PrintStream out> -> $r3 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r3.<java.io.PrintStream: void println(java.lang.String)>("The no of threads has not been specified, defaulting to 1") -> $r4 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r4.<java.io.PrintStream: void println(java.lang.String)>("  ") -> <JGFMonteCarloBenchSizeA: int nthreads> = 1 -> $i0 = <JGFMonteCarloBenchSizeA: int nthreads> -> staticinvoke <jgfutil.JGFInstrumentor: void printHeader(int,int,int)>(3, 0, $i0) -> $r5 = new montecarlo.JGFMonteCarloBench -> $i3 = <JGFMonteCarloBenchSizeA: int nthreads> -> specialinvoke $r5.<montecarlo.JGFMonteCarloBench: void <init>(int)>($i3) -> r1 = $r5 -> virtualinvoke r1.<montecarlo.JGFMonteCarloBench: void JGFrun(int)>(0) ->  End~~~1
Start -> r0 := @this: montecarlo.JGFMonteCarloBench -> i0 := @parameter0: int -> staticinvoke <jgfutil.JGFInstrumentor: void addTimer(java.lang.String,java.lang.String,int)>("Section3:MonteCarlo:Total", "Solutions", i0) -> staticinvoke <jgfutil.JGFInstrumentor: void addTimer(java.lang.String,java.lang.String,int)>("Section3:MonteCarlo:Run", "Samples", i0) -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void JGFsetsize(int)>(i0) -> r0 := @this: montecarlo.JGFMonteCarloBench -> i0 := @parameter0: int -> r0.<montecarlo.JGFMonteCarloBench: int size> = i0 -> return -> staticinvoke <jgfutil.JGFInstrumentor: void startTimer(java.lang.String)>("Section3:MonteCarlo:Total") -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void JGFinitialise()>() -> r0 := @this: montecarlo.JGFMonteCarloBench -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void initialise()>() ->  End~~~1
Start -> r0 := @this: montecarlo.CallAppDemo -> $r3 = r0.<montecarlo.CallAppDemo: int[] input> -> $r3[0] = 1000 -> $r4 = r0.<montecarlo.CallAppDemo: int[] input> -> $r5 = r0.<montecarlo.CallAppDemo: int[] datasizes> -> $i0 = r0.<montecarlo.CallAppDemo: int size> -> $i1 = $r5[$i0] -> $r4[1] = $i1 -> r1 = "Data" -> r2 = "hitData" -> $r6 = new montecarlo.AppDemo -> $r7 = r0.<montecarlo.CallAppDemo: int[] input> -> $i2 = $r7[0] -> $r8 = r0.<montecarlo.CallAppDemo: int[] input> -> $i3 = $r8[1] -> specialinvoke $r6.<montecarlo.AppDemo: void <init>(java.lang.String,java.lang.String,int,int)>(r1, r2, $i2, $i3) -> r0.<montecarlo.CallAppDemo: montecarlo.AppDemo ap> = $r6 -> $r9 = r0.<montecarlo.CallAppDemo: montecarlo.AppDemo ap> -> virtualinvoke $r9.<montecarlo.AppDemo: void initSerial()>() -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void JGFapplication()>() ->  End~~~1
Start -> r0 := @this: montecarlo.JGFMonteCarloBench -> staticinvoke <jgfutil.JGFInstrumentor: void startTimer(java.lang.String)>("Section3:MonteCarlo:Run") -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void runiters()>() ->  End~~~1
Start -> r0 := @this: montecarlo.CallAppDemo -> $r1 = r0.<montecarlo.CallAppDemo: montecarlo.AppDemo ap> -> virtualinvoke $r1.<montecarlo.AppDemo: void runThread()>() ->  End~~~1
Start -> r0 := @this: montecarlo.AppDemo -> $r1 = new java.util.Vector -> $i1 = r0.<montecarlo.AppDemo: int nRunsMC> -> specialinvoke $r1.<java.util.Vector: void <init>(int)>($i1) -> <montecarlo.AppDemo: java.util.Vector results> = $r1 -> $i2 = <montecarlo.JGFMonteCarloBench: int nthreads> -> r2 = newarray (java.lang.Runnable)[$i2] -> $i3 = <montecarlo.JGFMonteCarloBench: int nthreads> -> r3 = newarray (java.lang.Thread)[$i3] -> i0 = 1 -> goto [?= $i5 = <montecarlo.JGFMonteCarloBench: int nthreads>] -> $i5 = <montecarlo.JGFMonteCarloBench: int nthreads> -> if i0 < $i5 goto $r5 = new montecarlo.AppDemoThread -> $r9 = new montecarlo.AppDemoThread -> $i6 = r0.<montecarlo.AppDemo: int nRunsMC> -> specialinvoke $r9.<montecarlo.AppDemoThread: void <init>(int,int)>(0, $i6) -> r2[0] = $r9 -> $r10 = r2[0] -> interfaceinvoke $r10.<java.lang.Runnable: void run()>() ->  End~~~1
Start -> r0 := @this: montecarlo.AppDemoThread -> $i5 = r0.<montecarlo.AppDemoThread: int nRunsMC> -> $i0 = <montecarlo.JGFMonteCarloBench: int nthreads> -> $i6 = $i5 + $i0 -> $i7 = $i6 - 1 -> $i8 = <montecarlo.JGFMonteCarloBench: int nthreads> -> i1 = $i7 / $i8 -> $i9 = r0.<montecarlo.AppDemoThread: int id> -> i2 = $i9 * i1 -> $i10 = r0.<montecarlo.AppDemoThread: int id> -> $i11 = $i10 + 1 -> i3 = $i11 * i1 -> $i12 = r0.<montecarlo.AppDemoThread: int id> -> $i13 = <montecarlo.JGFMonteCarloBench: int nthreads> -> $i14 = $i13 - 1 -> if $i12 != $i14 goto i4 = i2 -> i3 = r0.<montecarlo.AppDemoThread: int nRunsMC> -> i4 = i2 -> goto [?= (branch)] -> if i4 < i3 goto $r2 = new montecarlo.PriceStock -> $r2 = new montecarlo.PriceStock -> specialinvoke $r2.<montecarlo.PriceStock: void <init>()>() -> r1 = $r2 -> $r3 = <montecarlo.AppDemo: montecarlo.ToInitAllTasks initAllTasks> -> virtualinvoke r1.<montecarlo.PriceStock: void setInitAllTasks(java.lang.Object)>($r3) -> $r4 = <montecarlo.AppDemo: java.util.Vector tasks> ->  End~~~1
Start -> $r5 = virtualinvoke $r4.<java.util.Vector: java.lang.Object elementAt(int)>(i4) -> virtualinvoke r1.<montecarlo.PriceStock: void setTask(java.lang.Object)>($r5) -> virtualinvoke r1.<montecarlo.PriceStock: void run()>() -> r0 := @this: montecarlo.PriceStock -> $r3 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> $l0 = r0.<montecarlo.PriceStock: long randomSeed> -> virtualinvoke $r3.<montecarlo.MonteCarloPath: void computeFluctuationsGaussian(long)>($l0) -> $r4 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> ->  End~~~10000
Start -> $d0 = r0.<montecarlo.PriceStock: double pathStartValue> -> virtualinvoke $r4.<montecarlo.MonteCarloPath: void computePathValue(double)>($d0) -> $r5 = new montecarlo.RatePath -> $r6 = r0.<montecarlo.PriceStock: montecarlo.MonteCarloPath mcPath> -> specialinvoke $r5.<montecarlo.RatePath: void <init>(montecarlo.MonteCarloPath)>($r6) ->  End~~~10000
Start -> r0 := @this: montecarlo.RatePath -> r1 := @parameter0: montecarlo.MonteCarloPath -> specialinvoke r0.<montecarlo.PathId: void <init>()>() -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = 0 -> $r2 = virtualinvoke r1.<montecarlo.MonteCarloPath: java.lang.String get_name()>() -> virtualinvoke r0.<montecarlo.RatePath: void set_name(java.lang.String)>($r2) ->  End~~~9999
Start -> r0 := @this: montecarlo.PathId -> r1 := @parameter0: java.lang.String -> r0.<montecarlo.PathId: java.lang.String name> = r1 -> return -> r0 := @this: montecarlo.PathId -> $i0 = virtualinvoke r1.<montecarlo.MonteCarloPath: int get_startDate()>() -> virtualinvoke r0.<montecarlo.RatePath: void set_startDate(int)>($i0) -> r2 = virtualinvoke r1.<montecarlo.RatePath: montecarlo.ReturnPath getReturnCompounded()>() ->  End~~~9999
Start -> virtualinvoke r2.<montecarlo.ReturnPath: void estimatePath()>() -> $d1 = virtualinvoke r2.<montecarlo.ReturnPath: double get_expectedReturnRate()>() -> $r7 = virtualinvoke r1.<montecarlo.PriceStock: java.lang.Object getResult()>() ->  End~~~9999
Start -> virtualinvoke $r6.<java.util.Vector: void addElement(java.lang.Object)>($r7) -> i4 = i4 + 1 -> if i4 < i3 goto $r2 = new montecarlo.PriceStock -> $r2 = new montecarlo.PriceStock -> specialinvoke $r2.<montecarlo.PriceStock: void <init>()>() -> r1 = $r2 -> $r3 = <montecarlo.AppDemo: montecarlo.ToInitAllTasks initAllTasks> -> virtualinvoke r1.<montecarlo.PriceStock: void setInitAllTasks(java.lang.Object)>($r3) -> $r4 = <montecarlo.AppDemo: java.util.Vector tasks> ->  End~~~9999
Start -> r0 := @this: montecarlo.RatePath -> r1 := @parameter0: montecarlo.MonteCarloPath -> specialinvoke r0.<montecarlo.PathId: void <init>()>() -> r0.<montecarlo.RatePath: int nAcceptedPathValue> = 0 -> $r2 = virtualinvoke r1.<montecarlo.MonteCarloPath: java.lang.String get_name()>() -> virtualinvoke r0.<montecarlo.RatePath: void set_name(java.lang.String)>($r2) -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void JGFvalidate()>() ->  End~~~1
Start -> r0 := @this: montecarlo.JGFMonteCarloBench -> $r2 = newarray (double)[2] -> $r2[0] = -0.0333976656762814 -> $r2[1] = -0.03215796752868655 -> r1 = $r2 -> $d1 = <montecarlo.AppDemo: double JGFavgExpectedReturnRateMC> -> $i0 = r0.<montecarlo.JGFMonteCarloBench: int size> -> $d2 = r1[$i0] -> $d3 = $d1 - $d2 -> d0 = staticinvoke <java.lang.Math: double abs(double)>($d3) -> $b1 = d0 cmpl 1.0E-12 -> if $b1 <= 0 goto return -> return -> virtualinvoke r0.<montecarlo.JGFMonteCarloBench: void JGFtidyup()>() ->  End~~~1
Start -> r0 := @this: montecarlo.JGFMonteCarloBench -> staticinvoke <java.lang.System: void gc()>() -> return -> staticinvoke <jgfutil.JGFInstrumentor: void stopTimer(java.lang.String)>("Section3:MonteCarlo:Total") -> $r1 = r0.<montecarlo.JGFMonteCarloBench: int[] input> ->  End~~~1
Start -> $i1 = $r1[1] -> $d0 = (double) $i1 -> staticinvoke <jgfutil.JGFInstrumentor: void addOpsToTimer(java.lang.String,double)>("Section3:MonteCarlo:Run", $d0) -> staticinvoke <jgfutil.JGFInstrumentor: void addOpsToTimer(java.lang.String,double)>("Section3:MonteCarlo:Total", 1.0) -> staticinvoke <jgfutil.JGFInstrumentor: void printTimer(java.lang.String)>("Section3:MonteCarlo:Run") ->  End~~~1
