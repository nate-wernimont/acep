Start -> $r0 = new java.util.Hashtable -> specialinvoke $r0.<java.util.Hashtable: void <init>()>() -> <jgfutil.JGFInstrumentor: java.util.Hashtable timers> = $r0 -> $r1 = new java.util.Hashtable -> specialinvoke $r1.<java.util.Hashtable: void <init>()>() -> <jgfutil.JGFInstrumentor: java.util.Hashtable data> = $r1 -> return -> i0 := @parameter0: int -> i1 := @parameter1: int -> i2 := @parameter2: int -> r0 = "" -> r1 = "Java Grande Forum Thread Benchmark Suite - Version 1.0 - Section " -> $r5 = new java.lang.StringBuilder -> $r6 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>(r1) -> specialinvoke $r5.<java.lang.StringBuilder: void <init>(java.lang.String)>($r6) -> $r7 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("2 - Size A") -> r0 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.String toString()>() -> goto [?= $r20 = <java.lang.System: java.io.PrintStream out>] -> $r20 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r20.<java.io.PrintStream: void println(java.lang.String)>(r0) -> if i2 != 1 goto $r26 = <java.lang.System: java.io.PrintStream out> -> $r21 = <java.lang.System: java.io.PrintStream out> -> $r22 = new java.lang.StringBuilder -> specialinvoke $r22.<java.lang.StringBuilder: void <init>(java.lang.String)>("Executing on ") -> $r23 = virtualinvoke $r22.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(i2) -> $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" thread") -> $r25 = virtualinvoke $r24.<java.lang.StringBuilder: java.lang.String toString()>() -> virtualinvoke $r21.<java.io.PrintStream: void println(java.lang.String)>($r25) -> goto [?= $r31 = <java.lang.System: java.io.PrintStream out>] -> $r31 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r31.<java.io.PrintStream: void println(java.lang.String)>("") -> return ->  End~~~1
Start -> r0 := @this: lufact.Linpack -> specialinvoke r0.<java.lang.Object: void <init>()>() -> return ->  End~~~1
Start -> r0 := @this: lufact.JGFLUFactBench -> i0 := @parameter0: int -> specialinvoke r0.<lufact.Linpack: void <init>()>() -> $r1 = newarray (int)[3] -> $r1[0] = 500 -> $r1[1] = 1000 -> $r1[2] = 2000 -> r0.<lufact.JGFLUFactBench: int[] datasizes> = $r1 -> <lufact.JGFLUFactBench: int nthreads> = i0 -> return ->  End~~~1
Start -> r0 := @this: jgfutil.JGFTimer -> r1 := @parameter0: java.lang.String -> r2 := @parameter1: java.lang.String -> i0 := @parameter2: int -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<jgfutil.JGFTimer: int size> = -1 -> r0.<jgfutil.JGFTimer: java.lang.String name> = r1 -> r0.<jgfutil.JGFTimer: java.lang.String opname> = r2 -> r0.<jgfutil.JGFTimer: int size> = i0 -> virtualinvoke r0.<jgfutil.JGFTimer: void reset()>() -> r0 := @this: jgfutil.JGFTimer -> r0.<jgfutil.JGFTimer: double time> = 0.0 -> r0.<jgfutil.JGFTimer: long calls> = 0L -> r0.<jgfutil.JGFTimer: double opcount> = 0.0 -> r0.<jgfutil.JGFTimer: boolean on> = 0 -> return -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String -> r1 := @parameter1: java.lang.String -> i0 := @parameter2: int -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r2.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r8 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r8 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r9 = new jgfutil.JGFTimer -> specialinvoke $r9.<jgfutil.JGFTimer: void <init>(java.lang.String,java.lang.String,int)>(r0, r1, i0) -> virtualinvoke $r8.<java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>(r0, $r9) -> return ->  End~~~1
Start -> r0 := @this: lufact.Linpack -> r1 := @parameter0: double[][] -> i0 := @parameter1: int -> i1 := @parameter2: int -> r2 := @parameter3: double[] -> i2 = 1325 -> d0 = 0.0 -> i3 = 0 -> goto [?= (branch)] -> if i3 < i1 goto i4 = 0 -> i4 = 0 -> if i4 < i1 goto $i5 = 3125 * i2 -> $i5 = 3125 * i2 -> i2 = $i5 % 65536 -> $r3 = r1[i4] -> $d1 = (double) i2 -> $d2 = $d1 - 32768.0 -> $d3 = $d2 / 16384.0 -> $r3[i3] = $d3 -> $r4 = r1[i4] -> $d4 = $r4[i3] -> $b6 = $d4 cmpl d0 -> if $b6 <= 0 goto $d5 = d0 -> $d5 = d0 -> d0 = $d5 -> i4 = i4 + 1 -> $r5 = r1[i4] -> $d5 = $r5[i3] -> goto [?= d0 = $d5] -> i3 = i3 + 1 -> i7 = 0 -> if i7 < i1 goto r2[i7] = 0.0 -> r2[i7] = 0.0 -> i7 = i7 + 1 -> i8 = 0 -> if i8 < i1 goto i9 = 0 -> i9 = 0 -> if i9 < i1 goto $d6 = r2[i9] -> $d6 = r2[i9] -> $r7 = r1[i8] -> $d7 = $r7[i9] -> $d8 = $d6 + $d7 -> r2[i9] = $d8 -> i9 = i9 + 1 -> i8 = i8 + 1 -> return d0 ->  End~~~907738
Start -> r0 := @this: lufact.Barrier -> i0 := @parameter0: int -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<lufact.Barrier: int numThreads> = i0 -> return ->  End~~~1
Start -> r0 := @this: lufact.TournamentBarrier -> i0 := @parameter0: int -> specialinvoke r0.<lufact.Barrier: void <init>(int)>(i0) -> r0.<lufact.TournamentBarrier: int maxBusyIter> = 1 -> $i2 = r0.<lufact.TournamentBarrier: int numThreads> -> $r1 = newarray (boolean)[$i2] -> r0.<lufact.TournamentBarrier: boolean[] IsDone> = $r1 -> i1 = 0 -> goto [?= (branch)] -> if i1 < i0 goto $r2 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $r2 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $r2[i1] = 0 -> i1 = i1 + 1 -> return ->  End~~~1
Start -> r0 := @this: jgfutil.JGFTimer -> $z0 = r0.<jgfutil.JGFTimer: boolean on> -> if $z0 == 0 goto r0.<jgfutil.JGFTimer: boolean on> = 1 -> r0.<jgfutil.JGFTimer: boolean on> = 1 -> $l0 = staticinvoke <java.lang.System: long currentTimeMillis()>() -> r0.<jgfutil.JGFTimer: long start_time> = $l0 -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void start()>() -> goto [?= return] -> return ->  End~~~1
Start -> r0 := @this: lufact.LinpackRunner -> i0 := @parameter0: int -> r1 := @parameter1: double[][] -> i1 := @parameter2: int -> i2 := @parameter3: int -> r2 := @parameter4: int[] -> r3 := @parameter5: lufact.Barrier -> specialinvoke r0.<java.lang.Object: void <init>()>() -> r0.<lufact.LinpackRunner: int id> = i0 -> r0.<lufact.LinpackRunner: double[][] a> = r1 -> r0.<lufact.LinpackRunner: int lda> = i1 -> r0.<lufact.LinpackRunner: int n> = i2 -> r0.<lufact.LinpackRunner: int[] ipvt> = r2 -> r0.<lufact.LinpackRunner: lufact.Barrier br> = r3 -> return ->  End~~~1
Start -> r0 := @this: lufact.TournamentBarrier -> i0 := @parameter0: int -> i1 = 3 -> $r1 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $z1 = $r1[i0] -> if $z1 == 0 goto $z2 = 1 -> $z2 = 1 -> z0 = $z2 -> goto [?= $i12 = i0 & i1] -> $i12 = i0 & i1 -> if $i12 != 0 goto $r3 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $i13 = r0.<lufact.TournamentBarrier: int numThreads> -> $i14 = $i13 << 2 -> if i1 < $i14 goto $i5 = i1 + 1 -> $i5 = i1 + 1 -> i2 = $i5 >> 2 -> i3 = 1 -> goto [?= (branch)] -> if i3 > 3 goto $i11 = i1 << 2 -> $i8 = i3 * i2 -> $i9 = i0 + $i8 -> $i10 = r0.<lufact.TournamentBarrier: int numThreads> -> if $i9 < $i10 goto i4 = r0.<lufact.TournamentBarrier: int maxBusyIter> -> $i11 = i1 << 2 -> i1 = $i11 + 3 -> $r3 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $r3[i0] = z0 -> i15 = r0.<lufact.TournamentBarrier: int maxBusyIter> -> goto [?= $r4 = r0.<lufact.TournamentBarrier: boolean[] IsDone>] -> $r4 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $z4 = $r4[0] -> if $z4 != z0 goto i15 = i15 + -1 -> return ->  End~~~1497
Start -> r0 := @this: lufact.TournamentBarrier -> i0 := @parameter0: int -> i1 = 3 -> $r1 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $z1 = $r1[i0] -> if $z1 == 0 goto $z2 = 1 -> $z2 = 0 -> goto [?= z0 = $z2] -> z0 = $z2 -> goto [?= $i12 = i0 & i1] -> $i12 = i0 & i1 -> if $i12 != 0 goto $r3 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $i13 = r0.<lufact.TournamentBarrier: int numThreads> -> $i14 = $i13 << 2 -> if i1 < $i14 goto $i5 = i1 + 1 -> $i5 = i1 + 1 -> i2 = $i5 >> 2 -> i3 = 1 -> goto [?= (branch)] -> if i3 > 3 goto $i11 = i1 << 2 -> $i8 = i3 * i2 -> $i9 = i0 + $i8 -> $i10 = r0.<lufact.TournamentBarrier: int numThreads> -> if $i9 < $i10 goto i4 = r0.<lufact.TournamentBarrier: int maxBusyIter> -> $i11 = i1 << 2 -> i1 = $i11 + 3 -> $r3 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $r3[i0] = z0 -> i15 = r0.<lufact.TournamentBarrier: int maxBusyIter> -> goto [?= $r4 = r0.<lufact.TournamentBarrier: boolean[] IsDone>] -> $r4 = r0.<lufact.TournamentBarrier: boolean[] IsDone> -> $z4 = $r4[0] -> if $z4 != z0 goto i15 = i15 + -1 -> return ->  End~~~1497
Start -> r0 := @this: lufact.LinpackRunner -> z0 = 0 -> $i8 = r0.<lufact.LinpackRunner: int n> -> i0 = $i8 - 1 -> if i0 < 0 goto $i40 = r0.<lufact.LinpackRunner: int id> -> i1 = 0 -> goto [?= (branch)] -> if i1 < i0 goto $r3 = r0.<lufact.LinpackRunner: double[][] a> -> $r3 = r0.<lufact.LinpackRunner: double[][] a> -> r1 = $r3[i1] -> i2 = i1 + 1 -> $i9 = r0.<lufact.LinpackRunner: int n> -> $i10 = $i9 - i1 -> r0 := @this: lufact.LinpackRunner -> i0 := @parameter0: int -> r1 := @parameter1: double[] -> i1 := @parameter2: int -> i2 := @parameter3: int -> i3 = 0 -> if i0 >= 1 goto (branch) -> if i0 != 1 goto (branch) -> if i2 == 1 goto i3 = 0 -> $i9 = 0 + i1 -> $d4 = r1[$i9] -> r0 := @this: lufact.LinpackRunner -> d0 := @parameter0: double -> $b0 = d0 cmpl 0.0 -> if $b0 < 0 goto $d1 = neg d0 -> $d1 = neg d0 -> return $d1 -> d5 = virtualinvoke r0.<lufact.LinpackRunner: double abs(double)>($d4) -> i10 = 1 -> goto [?= (branch)] -> if i10 < i0 goto $i11 = i10 + i1 -> $i11 = i10 + i1 -> $d6 = r1[$i11] -> $d1 = d0 -> goto [?= return $d1] -> d7 = virtualinvoke r0.<lufact.LinpackRunner: double abs(double)>($d6) -> $b12 = d7 cmpl d5 -> if $b12 <= 0 goto i10 = i10 + 1 -> i10 = i10 + 1 -> i3 = i10 -> d5 = d7 -> return i3 -> $i11 = virtualinvoke r0.<lufact.LinpackRunner: int idamax(int,double[],int,int)>($i10, r1, i1, 1) -> i3 = $i11 + i1 -> $i12 = r0.<lufact.LinpackRunner: int id> -> if $i12 != 0 goto $r5 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $r4 = r0.<lufact.LinpackRunner: int[] ipvt> -> $r4[i1] = i3 -> $r5 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $i13 = r0.<lufact.LinpackRunner: int id> -> virtualinvoke $r5.<lufact.Barrier: void DoBarrier(int)>($i13) -> $d1 = r1[i3] -> $b14 = $d1 cmpl 0.0 -> if $b14 == 0 goto i38 = i1 -> $r6 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $i15 = r0.<lufact.LinpackRunner: int id> -> virtualinvoke $r6.<lufact.Barrier: void DoBarrier(int)>($i15) -> $i16 = r0.<lufact.LinpackRunner: int id> -> if $i16 != 0 goto $r7 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> if i3 == i1 goto $r7 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> d0 = r1[i3] -> $d2 = r1[i1] -> r1[i3] = $d2 -> r1[i1] = d0 -> $r7 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $i17 = r0.<lufact.LinpackRunner: int id> -> virtualinvoke $r7.<lufact.Barrier: void DoBarrier(int)>($i17) -> $d3 = r1[i1] -> d4 = -1.0 / $d3 -> $i18 = r0.<lufact.LinpackRunner: int id> -> if $i18 != 0 goto $r8 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $i19 = r0.<lufact.LinpackRunner: int n> -> $i20 = $i19 - i2 -> virtualinvoke r0.<lufact.LinpackRunner: void dscal(int,double,double[],int,int)>($i20, d4, r1, i2, 1) -> r0 := @this: lufact.LinpackRunner -> i0 := @parameter0: int -> d0 := @parameter1: double -> r1 := @parameter2: double[] -> i1 := @parameter3: int -> i2 := @parameter4: int -> if i0 <= 0 goto return -> if i2 == 1 goto i6 = 0 -> i6 = 0 -> goto [?= (branch)] -> if i6 < i0 goto $i7 = i6 + i1 -> $i7 = i6 + i1 -> $d3 = r1[$i7] -> $d4 = $d3 * d0 -> r1[$i7] = $d4 -> i6 = i6 + 1 -> return -> $r8 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $i21 = r0.<lufact.LinpackRunner: int id> -> virtualinvoke $r8.<lufact.Barrier: void DoBarrier(int)>($i21) -> $i22 = r0.<lufact.LinpackRunner: int n> -> $i23 = $i22 - i2 -> $i24 = <lufact.JGFLUFactBench: int nthreads> -> $i25 = $i23 + $i24 -> $i26 = $i25 - 1 -> $i27 = <lufact.JGFLUFactBench: int nthreads> -> i4 = $i26 / $i27 -> $i28 = r0.<lufact.LinpackRunner: int id> -> $i29 = $i28 * i4 -> i5 = $i29 + i2 -> $i30 = r0.<lufact.LinpackRunner: int id> -> $i31 = $i30 + 1 -> $i32 = $i31 * i4 -> i6 = $i32 + i2 -> $i33 = r0.<lufact.LinpackRunner: int n> -> if i6 <= $i33 goto $i34 = r0.<lufact.LinpackRunner: int n> -> $i34 = r0.<lufact.LinpackRunner: int n> -> if i5 <= $i34 goto i7 = i5 -> i7 = i5 -> if i7 < i6 goto $r9 = r0.<lufact.LinpackRunner: double[][] a> -> $r9 = r0.<lufact.LinpackRunner: double[][] a> -> r2 = $r9[i7] -> d5 = r2[i3] -> if i3 == i1 goto $i35 = r0.<lufact.LinpackRunner: int n> -> $d6 = r2[i1] -> r2[i3] = $d6 -> r2[i1] = d5 -> $i35 = r0.<lufact.LinpackRunner: int n> -> $i36 = $i35 - i2 -> virtualinvoke r0.<lufact.LinpackRunner: void daxpy(int,double,double[],int,int,double[],int,int)>($i36, d5, r1, i2, 1, r2, i2, 1) -> r0 := @this: lufact.LinpackRunner -> i0 := @parameter0: int -> d0 := @parameter1: double -> r1 := @parameter2: double[] -> i1 := @parameter3: int -> i2 := @parameter4: int -> r2 := @parameter5: double[] -> i3 := @parameter6: int -> i4 := @parameter7: int -> if i0 <= 0 goto return -> $b8 = d0 cmpl 0.0 -> if $b8 == 0 goto return -> if i2 != 1 goto i5 = 0 -> if i4 == 1 goto i15 = 0 -> i15 = 0 -> goto [?= (branch)] -> if i15 < i0 goto $i16 = i15 + i3 -> $i16 = i15 + i3 -> $d5 = r2[$i16] -> $i17 = i15 + i1 -> $d6 = r1[$i17] -> $d7 = d0 * $d6 -> $d8 = $d5 + $d7 -> r2[$i16] = $d8 -> i15 = i15 + 1 -> return -> i7 = i7 + 1 -> $r10 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $i37 = r0.<lufact.LinpackRunner: int id> -> virtualinvoke $r10.<lufact.Barrier: void DoBarrier(int)>($i37) -> goto [?= $r11 = r0.<lufact.LinpackRunner: lufact.Barrier br>] -> $r11 = r0.<lufact.LinpackRunner: lufact.Barrier br> -> $i39 = r0.<lufact.LinpackRunner: int id> -> virtualinvoke $r11.<lufact.Barrier: void DoBarrier(int)>($i39) -> i1 = i1 + 1 -> $i40 = r0.<lufact.LinpackRunner: int id> -> if $i40 != 0 goto $r13 = r0.<lufact.LinpackRunner: double[][] a> -> $r12 = r0.<lufact.LinpackRunner: int[] ipvt> -> $i41 = r0.<lufact.LinpackRunner: int n> -> $i42 = $i41 - 1 -> $i43 = r0.<lufact.LinpackRunner: int n> -> $i44 = $i43 - 1 -> $r12[$i42] = $i44 -> $r13 = r0.<lufact.LinpackRunner: double[][] a> -> $i45 = r0.<lufact.LinpackRunner: int n> -> $i46 = $i45 - 1 -> $r14 = $r13[$i46] -> $i47 = r0.<lufact.LinpackRunner: int n> -> $i48 = $i47 - 1 -> $d7 = $r14[$i48] -> $b49 = $d7 cmpl 0.0 -> if $b49 != 0 goto return -> return ->  End~~~37672889
Start -> r0 := @this: lufact.Linpack -> r1 := @parameter0: double[][] -> i0 := @parameter1: int -> i1 := @parameter2: int -> r2 := @parameter3: int[] -> r3 := @parameter4: double[] -> i2 := @parameter5: int -> i3 = i1 - 1 -> if i2 != 0 goto i12 = 0 -> if i3 < 1 goto i7 = 0 -> i4 = 0 -> goto [?= (branch)] -> if i4 < i3 goto i5 = r2[i4] -> i5 = r2[i4] -> d0 = r3[i5] -> if i5 == i4 goto i6 = i4 + 1 -> $d1 = r3[i4] -> r3[i5] = $d1 -> r3[i4] = d0 -> i6 = i4 + 1 -> $i8 = i1 - i6 -> $r4 = r1[i4] -> virtualinvoke r0.<lufact.Linpack: void daxpy(int,double,double[],int,int,double[],int,int)>($i8, d0, $r4, i6, 1, r3, i6, 1) -> r0 := @this: lufact.Linpack -> i0 := @parameter0: int -> d0 := @parameter1: double -> r1 := @parameter2: double[] -> i1 := @parameter3: int -> i2 := @parameter4: int -> r2 := @parameter5: double[] -> i3 := @parameter6: int -> i4 := @parameter7: int -> if i0 <= 0 goto return -> $b8 = d0 cmpl 0.0 -> if $b8 == 0 goto return -> if i2 != 1 goto i5 = 0 -> if i4 == 1 goto i15 = 0 -> i15 = 0 -> goto [?= (branch)] -> if i15 < i0 goto $i16 = i15 + i3 -> $i16 = i15 + i3 -> $d5 = r2[$i16] -> $i17 = i15 + i1 -> $d6 = r1[$i17] -> $d7 = d0 * $d6 -> $d8 = $d5 + $d7 -> r2[$i16] = $d8 -> i15 = i15 + 1 -> return -> i4 = i4 + 1 -> i7 = 0 -> if i7 < i1 goto $i9 = i7 + 1 -> $i9 = i7 + 1 -> i10 = i1 - $i9 -> $d2 = r3[i10] -> $r6 = r1[i10] -> $d3 = $r6[i10] -> $d4 = $d2 / $d3 -> r3[i10] = $d4 -> $d5 = r3[i10] -> d6 = neg $d5 -> $r7 = r1[i10] -> virtualinvoke r0.<lufact.Linpack: void daxpy(int,double,double[],int,int,double[],int,int)>(i10, d6, $r7, 0, 1, r3, 0, 1) -> i7 = i7 + 1 -> goto [?= return] -> return ->  End~~~224997
Start -> r0 := @this: jgfutil.JGFTimer -> $d0 = r0.<jgfutil.JGFTimer: double time> -> $l0 = staticinvoke <java.lang.System: long currentTimeMillis()>() -> $l1 = r0.<jgfutil.JGFTimer: long start_time> -> $l2 = $l0 - $l1 -> $d1 = (double) $l2 -> $d2 = $d1 / 1000.0 -> $d3 = $d0 + $d2 -> r0.<jgfutil.JGFTimer: double time> = $d3 -> $z0 = r0.<jgfutil.JGFTimer: boolean on> -> if $z0 != 0 goto $l3 = r0.<jgfutil.JGFTimer: long calls> -> $l3 = r0.<jgfutil.JGFTimer: long calls> -> $l4 = $l3 + 1L -> r0.<jgfutil.JGFTimer: long calls> = $l4 -> r0.<jgfutil.JGFTimer: boolean on> = 0 -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void stop()>() -> goto [?= return] -> return ->  End~~~1
Start -> r0 := @this: lufact.Linpack -> i0 := @parameter0: int -> r1 := @parameter1: double[] -> i1 := @parameter2: int -> i2 := @parameter3: int -> r2 := @parameter4: double[] -> r3 := @parameter5: double[][] -> i3 = 0 -> goto [?= (branch)] -> if i3 < i1 goto i4 = 0 -> i4 = 0 -> if i4 < i0 goto $d0 = r1[i4] -> $d0 = r1[i4] -> $d1 = r2[i3] -> $r5 = r3[i3] -> $d2 = $r5[i4] -> $d3 = $d1 * $d2 -> $d4 = $d0 + $d3 -> r1[i4] = $d4 -> i4 = i4 + 1 -> i3 = i3 + 1 -> return ->  End~~~225249
Start -> r0 := @this: lufact.Linpack -> d0 := @parameter0: double -> $b0 = d0 cmpl 0.0 -> if $b0 < 0 goto $d1 = neg d0 -> $d1 = d0 -> goto [?= return $d1] -> return $d1 ->  End~~~747
Start -> r0 := @this: lufact.Linpack -> d0 := @parameter0: double -> $b0 = d0 cmpl 0.0 -> if $b0 < 0 goto $d1 = neg d0 -> $d1 = neg d0 -> return $d1 ->  End~~~269
Start -> r0 := @this: lufact.Linpack -> d0 := @parameter0: double -> d1 = 1.3333333333333333 -> d2 = 0.0 -> goto [?= $b0 = d2 cmpl 0.0] -> $b0 = d2 cmpl 0.0 -> if $b0 == 0 goto d3 = d1 - 1.0 -> d3 = d1 - 1.0 -> $d5 = d3 + d3 -> d4 = $d5 + d3 -> $d6 = d4 - 1.0 -> r0 := @this: lufact.Linpack -> d0 := @parameter0: double -> $b0 = d0 cmpl 0.0 -> if $b0 < 0 goto $d1 = neg d0 -> $d1 = neg d0 -> return $d1 -> d2 = virtualinvoke r0.<lufact.Linpack: double abs(double)>($d6) -> $d1 = d0 -> goto [?= return $d1] -> $d7 = virtualinvoke r0.<lufact.Linpack: double abs(double)>(d0) -> $d8 = d2 * $d7 -> return $d8 ->  End~~~1
Start -> r0 := @this: jgfutil.JGFTimer -> d0 := @parameter0: double -> $d1 = r0.<jgfutil.JGFTimer: double opcount> -> $d2 = $d1 + d0 -> r0.<jgfutil.JGFTimer: double opcount> = $d2 -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String -> d0 := @parameter1: double -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void addops(double)>(d0) -> goto [?= return] -> return ->  End~~~1
Start -> r0 := @this: jgfutil.JGFTimer -> $r1 = r0.<jgfutil.JGFTimer: java.lang.String opname> -> $z0 = virtualinvoke $r1.<java.lang.String: boolean equals(java.lang.Object)>("") -> if $z0 == 0 goto $i0 = r0.<jgfutil.JGFTimer: int size> -> $i0 = r0.<jgfutil.JGFTimer: int size> -> $r10 = <java.lang.System: java.io.PrintStream out> -> $r11 = new java.lang.StringBuilder -> $r12 = r0.<jgfutil.JGFTimer: java.lang.String name> -> $r13 = staticinvoke <java.lang.String: java.lang.String valueOf(java.lang.Object)>($r12) -> specialinvoke $r11.<java.lang.StringBuilder: void <init>(java.lang.String)>($r13) -> $r14 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(":SizeA") -> $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\t") -> $d1 = r0.<jgfutil.JGFTimer: double time> -> $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.StringBuilder append(double)>($d1) -> $r17 = virtualinvoke $r16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" (s) \t ") -> r0 := @this: jgfutil.JGFTimer -> $d0 = r0.<jgfutil.JGFTimer: double opcount> -> $d1 = r0.<jgfutil.JGFTimer: double time> -> $d2 = $d0 / $d1 -> return $d2 -> $d2 = virtualinvoke r0.<jgfutil.JGFTimer: double perf()>() -> $f0 = (float) $d2 -> $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(float)>($f0) -> $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("\t") -> $r20 = virtualinvoke $r19.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" (") -> $r21 = r0.<jgfutil.JGFTimer: java.lang.String opname> -> $r22 = virtualinvoke $r20.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r21) -> $r23 = virtualinvoke $r22.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("/s)") -> $r24 = virtualinvoke $r23.<java.lang.StringBuilder: java.lang.String toString()>() -> virtualinvoke $r10.<java.io.PrintStream: void println(java.lang.String)>($r24) -> goto [?= return] -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String -> $r1 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $z0 = virtualinvoke $r1.<java.util.Hashtable: boolean containsKey(java.lang.Object)>(r0) -> if $z0 == 0 goto $r5 = <java.lang.System: java.io.PrintStream out> -> $r2 = <jgfutil.JGFInstrumentor: java.util.Hashtable timers> -> $r3 = virtualinvoke $r2.<java.util.Hashtable: java.lang.Object get(java.lang.Object)>(r0) -> $r4 = (jgfutil.JGFTimer) $r3 -> virtualinvoke $r4.<jgfutil.JGFTimer: void print()>() -> goto [?= return] -> return ->  End~~~1
Start -> r0 := @this: lufact.JGFLUFactBench -> i0 := @parameter0: int -> staticinvoke <jgfutil.JGFInstrumentor: void addTimer(java.lang.String,java.lang.String,int)>("Section2:LUFact:Kernel", "Mflops", i0) -> virtualinvoke r0.<lufact.JGFLUFactBench: void JGFsetsize(int)>(i0) -> r0 := @this: lufact.JGFLUFactBench -> i0 := @parameter0: int -> r0.<lufact.JGFLUFactBench: int size> = i0 -> return -> virtualinvoke r0.<lufact.JGFLUFactBench: void JGFinitialise()>() -> r0 := @this: lufact.JGFLUFactBench -> $r1 = r0.<lufact.JGFLUFactBench: int[] datasizes> -> $i1 = r0.<lufact.JGFLUFactBench: int size> -> $i2 = $r1[$i1] -> r0.<lufact.JGFLUFactBench: int n> = $i2 -> $i3 = r0.<lufact.JGFLUFactBench: int n> -> r0.<lufact.JGFLUFactBench: int ldaa> = $i3 -> $i4 = r0.<lufact.JGFLUFactBench: int ldaa> -> $i5 = $i4 + 1 -> r0.<lufact.JGFLUFactBench: int lda> = $i5 -> $i6 = r0.<lufact.JGFLUFactBench: int ldaa> -> $i7 = r0.<lufact.JGFLUFactBench: int lda> -> $r2 = newmultiarray (double)[$i6][$i7] -> r0.<lufact.JGFLUFactBench: double[][] a> = $r2 -> $i8 = r0.<lufact.JGFLUFactBench: int ldaa> -> $r3 = newarray (double)[$i8] -> r0.<lufact.JGFLUFactBench: double[] b> = $r3 -> $i9 = r0.<lufact.JGFLUFactBench: int ldaa> -> $r4 = newarray (double)[$i9] -> r0.<lufact.JGFLUFactBench: double[] x> = $r4 -> $i10 = r0.<lufact.JGFLUFactBench: int ldaa> -> $r5 = newarray (int)[$i10] -> r0.<lufact.JGFLUFactBench: int[] ipvt> = $r5 -> $i11 = r0.<lufact.JGFLUFactBench: int n> -> l0 = (long) $i11 -> $l12 = l0 * l0 -> $l13 = $l12 * l0 -> $d0 = (double) $l13 -> $d1 = 2.0 * $d0 -> $d2 = $d1 / 3.0 -> $l14 = l0 * l0 -> $d3 = (double) $l14 -> $d4 = 2.0 * $d3 -> $d5 = $d2 + $d4 -> r0.<lufact.JGFLUFactBench: double ops> = $d5 -> $r6 = r0.<lufact.JGFLUFactBench: double[][] a> -> $i15 = r0.<lufact.JGFLUFactBench: int lda> -> $i16 = r0.<lufact.JGFLUFactBench: int n> -> $r7 = r0.<lufact.JGFLUFactBench: double[] b> -> $d6 = virtualinvoke r0.<lufact.JGFLUFactBench: double matgen(double[][],int,int,double[])>($r6, $i15, $i16, $r7) -> r0.<lufact.JGFLUFactBench: double norma> = $d6 -> return -> virtualinvoke r0.<lufact.JGFLUFactBench: void JGFkernel()>() -> r0 := @this: lufact.JGFLUFactBench -> $i0 = <lufact.JGFLUFactBench: int nthreads> -> r1 = newarray (java.lang.Runnable)[$i0] -> $i3 = <lufact.JGFLUFactBench: int nthreads> -> r2 = newarray (java.lang.Thread)[$i3] -> $r5 = new lufact.TournamentBarrier -> $i1 = <lufact.JGFLUFactBench: int nthreads> -> specialinvoke $r5.<lufact.TournamentBarrier: void <init>(int)>($i1) -> r3 = $r5 -> staticinvoke <jgfutil.JGFInstrumentor: void startTimer(java.lang.String)>("Section2:LUFact:Kernel") -> i2 = 1 -> goto [?= $i6 = <lufact.JGFLUFactBench: int nthreads>] -> $i6 = <lufact.JGFLUFactBench: int nthreads> -> if i2 < $i6 goto $r6 = new lufact.LinpackRunner -> $r12 = new lufact.LinpackRunner -> $r13 = r0.<lufact.JGFLUFactBench: double[][] a> -> $i7 = r0.<lufact.JGFLUFactBench: int lda> -> $i8 = r0.<lufact.JGFLUFactBench: int n> -> $r14 = r0.<lufact.JGFLUFactBench: int[] ipvt> -> specialinvoke $r12.<lufact.LinpackRunner: void <init>(int,double[][],int,int,int[],lufact.Barrier)>(0, $r13, $i7, $i8, $r14, r3) -> r1[0] = $r12 -> $r15 = r1[0] -> interfaceinvoke $r15.<java.lang.Runnable: void run()>() -> i9 = 1 -> goto [?= $i10 = <lufact.JGFLUFactBench: int nthreads>] -> $i10 = <lufact.JGFLUFactBench: int nthreads> -> if i9 < $i10 goto $r16 = r2[i9] -> $r18 = r0.<lufact.JGFLUFactBench: double[][] a> -> $i11 = r0.<lufact.JGFLUFactBench: int lda> -> $i12 = r0.<lufact.JGFLUFactBench: int n> -> $r19 = r0.<lufact.JGFLUFactBench: int[] ipvt> -> $r20 = r0.<lufact.JGFLUFactBench: double[] b> -> virtualinvoke r0.<lufact.JGFLUFactBench: void dgesl(double[][],int,int,int[],double[],int)>($r18, $i11, $i12, $r19, $r20, 0) -> staticinvoke <jgfutil.JGFInstrumentor: void stopTimer(java.lang.String)>("Section2:LUFact:Kernel") -> return -> virtualinvoke r0.<lufact.JGFLUFactBench: void JGFvalidate()>() -> r0 := @this: lufact.JGFLUFactBench -> $r2 = newarray (double)[3] -> $r2[0] = 6.0 -> $r2[1] = 12.0 -> $r2[2] = 20.0 -> r1 = $r2 -> i0 = 0 -> goto [?= $i1 = r0.<lufact.JGFLUFactBench: int n>] -> $i1 = r0.<lufact.JGFLUFactBench: int n> -> if i0 < $i1 goto $r3 = r0.<lufact.JGFLUFactBench: double[] x> -> $r3 = r0.<lufact.JGFLUFactBench: double[] x> -> $r4 = r0.<lufact.JGFLUFactBench: double[] b> -> $d2 = $r4[i0] -> $r3[i0] = $d2 -> i0 = i0 + 1 -> $r5 = r0.<lufact.JGFLUFactBench: double[][] a> -> $i2 = r0.<lufact.JGFLUFactBench: int lda> -> $i3 = r0.<lufact.JGFLUFactBench: int n> -> $r6 = r0.<lufact.JGFLUFactBench: double[] b> -> $d3 = virtualinvoke r0.<lufact.JGFLUFactBench: double matgen(double[][],int,int,double[])>($r5, $i2, $i3, $r6) -> r0.<lufact.JGFLUFactBench: double norma> = $d3 -> i4 = 0 -> goto [?= $i5 = r0.<lufact.JGFLUFactBench: int n>] -> $i5 = r0.<lufact.JGFLUFactBench: int n> -> if i4 < $i5 goto $r7 = r0.<lufact.JGFLUFactBench: double[] b> -> $r7 = r0.<lufact.JGFLUFactBench: double[] b> -> $r8 = r0.<lufact.JGFLUFactBench: double[] b> -> $d4 = $r8[i4] -> $d5 = neg $d4 -> $r7[i4] = $d5 -> i4 = i4 + 1 -> $i6 = r0.<lufact.JGFLUFactBench: int n> -> $r9 = r0.<lufact.JGFLUFactBench: double[] b> -> $i7 = r0.<lufact.JGFLUFactBench: int n> -> $i8 = r0.<lufact.JGFLUFactBench: int lda> -> $r10 = r0.<lufact.JGFLUFactBench: double[] x> -> $r11 = r0.<lufact.JGFLUFactBench: double[][] a> -> virtualinvoke r0.<lufact.JGFLUFactBench: void dmxpy(int,double[],int,int,double[],double[][])>($i6, $r9, $i7, $i8, $r10, $r11) -> r0.<lufact.JGFLUFactBench: double resid> = 0.0 -> r0.<lufact.JGFLUFactBench: double normx> = 0.0 -> i9 = 0 -> goto [?= $i12 = r0.<lufact.JGFLUFactBench: int n>] -> $i12 = r0.<lufact.JGFLUFactBench: int n> -> if i9 < $i12 goto $d6 = r0.<lufact.JGFLUFactBench: double resid> -> $d6 = r0.<lufact.JGFLUFactBench: double resid> -> $r13 = r0.<lufact.JGFLUFactBench: double[] b> -> $d7 = $r13[i9] -> $d8 = virtualinvoke r0.<lufact.JGFLUFactBench: double abs(double)>($d7) -> $b10 = $d6 cmpl $d8 -> if $b10 <= 0 goto $r14 = r0.<lufact.JGFLUFactBench: double[] b> -> $r14 = r0.<lufact.JGFLUFactBench: double[] b> -> $d10 = $r14[i9] -> $d9 = virtualinvoke r0.<lufact.JGFLUFactBench: double abs(double)>($d10) -> r0.<lufact.JGFLUFactBench: double resid> = $d9 -> $d11 = r0.<lufact.JGFLUFactBench: double normx> -> $r16 = r0.<lufact.JGFLUFactBench: double[] x> -> $d12 = $r16[i9] -> $d13 = virtualinvoke r0.<lufact.JGFLUFactBench: double abs(double)>($d12) -> $b11 = $d11 cmpl $d13 -> if $b11 <= 0 goto $r17 = r0.<lufact.JGFLUFactBench: double[] x> -> $r17 = r0.<lufact.JGFLUFactBench: double[] x> -> $d15 = $r17[i9] -> $d14 = virtualinvoke r0.<lufact.JGFLUFactBench: double abs(double)>($d15) -> r0.<lufact.JGFLUFactBench: double normx> = $d14 -> i9 = i9 + 1 -> $d9 = r0.<lufact.JGFLUFactBench: double resid> -> goto [?= r0.<lufact.JGFLUFactBench: double resid> = $d9] -> $d14 = r0.<lufact.JGFLUFactBench: double normx> -> goto [?= r0.<lufact.JGFLUFactBench: double normx> = $d14] -> d0 = virtualinvoke r0.<lufact.JGFLUFactBench: double epslon(double)>(1.0) -> $d16 = r0.<lufact.JGFLUFactBench: double resid> -> $i13 = r0.<lufact.JGFLUFactBench: int n> -> $d17 = (double) $i13 -> $d18 = r0.<lufact.JGFLUFactBench: double norma> -> $d19 = $d17 * $d18 -> $d20 = r0.<lufact.JGFLUFactBench: double normx> -> $d21 = $d19 * $d20 -> $d22 = $d21 * d0 -> d1 = $d16 / $d22 -> $i14 = r0.<lufact.JGFLUFactBench: int size> -> $d23 = r1[$i14] -> $b15 = d1 cmpl $d23 -> if $b15 <= 0 goto return -> return -> virtualinvoke r0.<lufact.JGFLUFactBench: void JGFtidyup()>() -> r0 := @this: lufact.JGFLUFactBench -> r0.<lufact.JGFLUFactBench: double[][] a> = null -> r0.<lufact.JGFLUFactBench: double[] b> = null -> r0.<lufact.JGFLUFactBench: double[] x> = null -> r0.<lufact.JGFLUFactBench: int[] ipvt> = null -> staticinvoke <java.lang.System: void gc()>() -> return -> $d0 = r0.<lufact.JGFLUFactBench: double ops> -> $d1 = $d0 / 1000000.0 -> staticinvoke <jgfutil.JGFInstrumentor: void addOpsToTimer(java.lang.String,double)>("Section2:LUFact:Kernel", $d1) -> staticinvoke <jgfutil.JGFInstrumentor: void printTimer(java.lang.String)>("Section2:LUFact:Kernel") -> return ->  End~~~1355
Start -> $i3 = <JGFLUFactBenchSizeA: int nthreads> -> specialinvoke $r5.<lufact.JGFLUFactBench: void <init>(int)>($i3) -> r1 = $r5 -> virtualinvoke r1.<lufact.JGFLUFactBench: void JGFrun(int)>(0) -> return ->  End~~~1
Start -> r0 := @parameter0: java.lang.String[] -> $i1 = lengthof r0 -> if $i1 == 0 goto $r3 = <java.lang.System: java.io.PrintStream out> -> $r3 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r3.<java.io.PrintStream: void println(java.lang.String)>("The no of threads has not been specified, defaulting to 1") -> $r4 = <java.lang.System: java.io.PrintStream out> -> virtualinvoke $r4.<java.io.PrintStream: void println(java.lang.String)>("  ") -> <JGFLUFactBenchSizeA: int nthreads> = 1 -> $i0 = <JGFLUFactBenchSizeA: int nthreads> -> staticinvoke <jgfutil.JGFInstrumentor: void printHeader(int,int,int)>(2, 0, $i0) ->  End~~~1
Start -> $r5 = new lufact.JGFLUFactBench ->  End~~~1
